<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>谈谈对长连接网关架构的设计（二）</title>
    <link href="/2022/11/24/%E8%B0%88%E8%B0%88%E5%AF%B9%E9%95%BF%E8%BF%9E%E6%8E%A5%E7%BD%91%E5%85%B3%E6%9E%B6%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2022/11/24/%E8%B0%88%E8%B0%88%E5%AF%B9%E9%95%BF%E8%BF%9E%E6%8E%A5%E7%BD%91%E5%85%B3%E6%9E%B6%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>文章接上文 <a href="https://younman.com/2022/11/10/%E8%B0%88%E8%B0%88%E5%AF%B9%E9%95%BF%E8%BF%9E%E6%8E%A5%E7%BD%91%E5%85%B3%E6%9E%B6%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1/" title="谈谈对长连接网关架构的设计"><strong>谈谈对长连接网关架构的设计</strong></a>。</p><p>本文会详细讲讲，我们对于长连接网关是如何思考与设计的。</p><span id="more"></span><h2 id="architecture"><a href="#architecture" class="headerlink" title="architecture"></a>architecture</h2><p><img src="/images/%E9%95%BF%E8%BF%9E%E6%8E%A5%E7%BD%91%E5%85%B3%E6%9E%B6%E6%9E%84.png" alt="长连接网关架构"></p><p>上文讲述了架构图中每个角色承担的能力，这篇文章我们会具体讲讲ws-gateway与ws-api的设计，这是整个架构中最重要的一环。</p><h2 id="ws-gateway"><a href="#ws-gateway" class="headerlink" title="ws-gateway"></a>ws-gateway</h2><p>ws-gateway是长连接网关，使用长连接协议与用户实时通信。这里的协议实现可能有多种，比如websocket，gRPC Streaming，webRTC等。</p><p>我们忽略ingress层。</p><h3 id="用户连接"><a href="#用户连接" class="headerlink" title="用户连接"></a>用户连接</h3><p>当用户和ws-gateway尝试建立连接时，ws-gateway会先做用户鉴权，成功后会与其建立一个websocket长连接通道。对于用户的websocket，ws-gateway会为其生成一个唯一的socketId，并保存socketId与websocket对象的映射关系。接着，会发布连接事件到ws-api系统，并带上当前的gatewayIP、socketId以及用户信息（比如uid信息等）。</p><h3 id="用户→服务端"><a href="#用户→服务端" class="headerlink" title="用户→服务端"></a>用户→服务端</h3><p>当收到在线用户的消息，ws-gateway会将消息带上gatewayIP，与当前的websocket信息（socketId），然后将其传递到ws-api系统。</p><h3 id="服务端→用户"><a href="#服务端→用户" class="headerlink" title="服务端→用户"></a>服务端→用户</h3><p>当收到ws-api系统的消息，ws-api发送过来的消息是必须要带上socketId的，通过socketId，我们可以找到对应的websocket通道，然后发送消息。</p><h3 id="用户断开"><a href="#用户断开" class="headerlink" title="用户断开"></a>用户断开</h3><p>当用户断开连接，ws-gateway会找到对应的socketId，然后下发用户断开事件到ws-api（带上gatewayIP、socketId和uid）。</p><h2 id="ws-api"><a href="#ws-api" class="headerlink" title="ws-api"></a>ws-api</h2><p>ws-api是ws-gateway与服务端系统沟通的桥梁。ws-api既为业务系统提供了推送消息的API，也通过MQ消息发布模式为业务系统提供接收在线用户消息的能力。</p><h3 id="用户连接-1"><a href="#用户连接-1" class="headerlink" title="用户连接"></a>用户连接</h3><p>当ws-gateway向ws-api发布连接事件（带上gatewayIP、socketId以及uid），ws-api系统会保存以下几种关联。</p><p>关系一：socketId: gateway关联。将socketId与gatewayIP信息保存在redis中，数据结构为String，通过心跳维持key的TTL，一个连接会占用一个redis key。</p><p>关系二：uid: socketId关联。存储在redis，一个用户可能会维持多个websocket连接，比如pc的多窗口。数据结构为Set，存储socketId集合。一个用户会占用一个redis key。</p><p>根据业务可以衍生出更多的关系，比如群ID、直播间ID等。</p><h3 id="用户→服务端-1"><a href="#用户→服务端-1" class="headerlink" title="用户→服务端"></a>用户→服务端</h3><p>当ws-gateway向ws-api下发用户消息，ws-api会通过消息中的业务码，将消息推送到对应的MQ topic中，由业务系统消费。</p><h3 id="服务端→用户-1"><a href="#服务端→用户-1" class="headerlink" title="服务端→用户"></a>服务端→用户</h3><p>当业务系统向ws-api推送实时消息（带上要推送的用户uid），ws-api会通过关系二，找到socketId集合，接着通过关系一，找到gatewayIP，接着就可以找到和对应节点的gRPC Streaming通道，然后推送消息。</p><h3 id="用户断开-1"><a href="#用户断开-1" class="headerlink" title="用户断开"></a>用户断开</h3><p>当ws-gateway向ws-api发布断开连接事件（带上gatewayIP、socketId和uid），ws-api会删除对应关系。</p><h2 id="系统交互"><a href="#系统交互" class="headerlink" title="系统交互"></a>系统交互</h2><p>ws-gateway和ws-api是相辅相成的，两者缺一不可，所有的业务系统都在ws-api的下游。</p><p>ws-gateway与ws-api数量是M:N的关系，每个ws-gateway都会和ws-api都会维持gRPC-Streaming通道。</p><p>ws-gateway配置ws-api服务发现节点，通过IP直连建立通信通道。</p><p>当ws-gateway启动后，通过服务发现ws-api节点IP，打开gRPC-Streaming通道维持连接。</p><p>当ws-api节点启动，ws-api不会主动连接ws-gateway，而是由ws-gateway去重连ws-api节点。</p><p>当ws-api收到ws-gateway的连接请求，连接成功后会维持gatewayIP与gRPC-Streaming通道的关联关系。</p><p><img src="/images/%E9%95%BF%E8%BF%9E%E6%8E%A5%E7%BD%91%E5%85%B3%E7%B3%BB%E7%BB%9F%E4%BA%A4%E4%BA%92.png" alt="长连接网关系统交互"></p><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p>自己简略实现了一些ws-gateway和ws-api功能，后续会完善相关能力，有兴趣的可转到Github项目。</p><p><a href="https://github.com/lyouthzzz/ws-gateway" title="https://github.com/lyouthzzz/ws-gateway">https://github.com/lyouthzzz/ws-gateway</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>谈谈对长连接网关架构的设计</title>
    <link href="/2022/11/10/%E8%B0%88%E8%B0%88%E5%AF%B9%E9%95%BF%E8%BF%9E%E6%8E%A5%E7%BD%91%E5%85%B3%E6%9E%B6%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/11/10/%E8%B0%88%E8%B0%88%E5%AF%B9%E9%95%BF%E8%BF%9E%E6%8E%A5%E7%BD%91%E5%85%B3%E6%9E%B6%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>最近接手了团队的在线消息系统，什么是在线消息系统，其实做的就是在线用户与服务端的消息即时通讯，可以理解为我们常见的消息中心，消息通知等业务。一般我们会通过websocket长连接技术去实现，当然，关于TCP长连接方案又很多，我们这里不去讨论。</p><span id="more"></span><p>由于历史原因，目前的在线消息系统的职责混杂，调用链混乱，业务耦合比较严重。所以近期我们准备对这个消息系统做一次全面的重构。</p><p>目前业务主要的痛点主要有这些：</p><ol><li><p> 服务的职责与职责边界划分不清楚</p></li><li><p> 没有形成业务闭环，与一些外部业务耦合在一起</p></li><li><p> 缺少应用的业务指标观测，无法知道在线用户，以及消息吞吐能力</p></li></ol><p>针对以上的问题，我们首先思考的应该就是如何去抽象通用能力，这样将之与业务隔离。因为业务是变化的，在快速迭代的过程中，我们只需要迭代我们的业务系统即可。</p><p>继而， 我们就可以将消息系统拆分为长连接网关，业务系统。</p><p>接触下来，会发现长连接网关真是一个非常有意思的技术。</p><p>首先是TCP长连接的稳定性问题，因为我们的客户端的环境时常是不稳定的，当进入电梯、开车进入隧道、切换wifi，都有可能导致我们长连接的断开。</p><p>当长连接异常断开的时候，对端其实也是无法感知到的，只有当你发生数据交换的时候，或者通过TCP的keepalive机制才会知道这条连接已经断开了。</p><p>类似的细节还有很多，我们需要很多技术手段去优化。</p><p>当然，我们今天谈的不是这个。</p><p>接下来聊一聊，我们对长连接网关设计的思考。尤其是石墨的长连接网关（感谢彭大的指导）以及毛大的goim项目对我们的设计有很大的启发。在References下会留下文章，大家可以详细的阅读。</p><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="/images/%E9%95%BF%E8%BF%9E%E6%8E%A5%E7%BD%91%E5%85%B3%E6%9E%B6%E6%9E%84.png" alt="长连接网关架构"></p><p>架构分层如上所示，接下来我们详细讲一讲每一层的职责与能力。</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端主要分为app端、pc端、h5端等。每个端都会与网关维护一条稳定的长连接。当然pc端的多窗口其实是多websocket连接了。</p><h3 id="ingress"><a href="#ingress" class="headerlink" title="ingress"></a>ingress</h3><p>ingress负责七层域名，这里可以是nginx组件也可以是k8s的ingress controller组件。</p><p>并且在这一层可以挂载证书，做TLS的加解密，继而将长连接代理到网关去。</p><p>这里要注意的是客户端和ingress这一层是wws协议，ingress和ws-gateway是ws协议。</p><h3 id="ws-gateway"><a href="#ws-gateway" class="headerlink" title="ws-gateway"></a>ws-gateway</h3><p>ws-gateway维护了所有用户登录后的ws长连接。有如下职责：</p><p>尽可能的去承担用户的ws长连接。</p><p>做用户鉴权，解析用户ID和一些业务ID。</p><p>负责将用户消息分到到下游，将服务端消息通知到在线用户。</p><p>生成socketId，并维护socketId与ws连接的关系。这里的sid在后续的设计中尤为重要。</p><p>网关的设计应该是稳定的，无业务的。</p><h3 id="ws-api"><a href="#ws-api" class="headerlink" title="ws-api"></a>ws-api</h3><p>ws-api是业务系统与网关的媒介。换句话说，它是业务系统与在线用户沟通的桥梁。</p><p>ws-api与网关的信息交互，我们一开始的设计是ws通道，后续切换到了gRPC-Stream。关于这里的思考，大家可以看一些关于gRPC-Stream websocket的文章。</p><p>ws-api的职责如下：</p><p>负责向在线用户通知实时消息的API。</p><p>负责维护多个维度的映射关系。</p><p>负责消息广播，将一条消息广播到各个gateway的节点上。</p><p>负责维护连接的心跳（通过redis key ttl实现）。</p><p>负责消息/用户连接等指标统计。</p><p>负责将在线用户消息下发到MQ Topic中，由下游的业务系统消费。</p><p>ws-api与ws-gateway是打包在一起的，一切业务皆在下游。</p><h3 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h3><p>消息中间件，可以是RocketMQ，可以是Kafka，主要是做网关与业务系统的解藕。</p><p>下面我们来一起几个业务流程场景</p><ol><li><p> 业务系统推送<br><img src="/images/%E9%95%BF%E8%BF%9E%E6%8E%A5%E7%BD%91%E5%85%B3-%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%8E%A8%E9%80%81.png" alt="业务系统推送"></p></li><li><p>在线用户消息推送<br><img src="/images/%E9%95%BF%E8%BF%9E%E6%8E%A5%E7%BD%91%E5%85%B3-%E5%9C%A8%E7%BA%BF%E7%94%A8%E6%88%B7%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81.png" alt="在线用户消息推送"></p></li><li><p>通用事件设计（用户连接与关闭连接）<br><img src="/images/%E9%95%BF%E8%BF%9E%E6%8E%A5%E7%BD%91%E5%85%B3-%E9%80%9A%E7%94%A8%E4%BA%8B%E4%BB%B6%E8%AE%BE%E8%AE%A1.png" alt="通用事件设计"></p></li></ol><p>关于ws-gateway与ws-api的交互是需要深入思考的，如何去通知到ws-gateway的一批或者指定的websocket通道，后面可以简单聊聊我们是怎么做的。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://mp.weixin.qq.com/s/MUourpb0IqqFo5XlxRLE0w" title="https://mp.weixin.qq.com/s/MUourpb0IqqFo5XlxRLE0w">https://mp.weixin.qq.com/s/MUourpb0IqqFo5XlxRLE0w</a></p><p><a href="https://github.com/Terry-Mao/goim" title="https://github.com/Terry-Mao/goim">https://github.com/Terry-Mao/goim</a></p><p><a href="https://ably.com/topic/grpc-vs-websocket" title="https://ably.com/topic/grpc-vs-websocket">https://ably.com/topic/grpc-vs-websocket</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Function Options设计模式</title>
    <link href="/2022/08/15/FunctionOptionsDesign/"/>
    <url>/2022/08/15/FunctionOptionsDesign/</url>
    
    <content type="html"><![CDATA[<p>在编程中，我们会编写很多对象的构造函数。如何优雅的设计对象的构造函数是本篇文章的主题，并且会引出介绍Go语言中流行的<code>Function Options</code>设计模式。</p><span id="more"></span><p>在编程中，我们经常会需要一个对象进行相关的参数配置。比如下面的Server对象：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Server <span class="hljs-keyword">struct</span> &#123;<br>  Addr     <span class="hljs-keyword">string</span><br>  Port     <span class="hljs-keyword">int</span><br>  Timeout  time.Duration<br>  MaxConns <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> ServerConfig <span class="hljs-keyword">struct</span> &#123;<br>  Addr     <span class="hljs-keyword">string</span><br>  Port     <span class="hljs-keyword">int</span><br>  Timeout  time.Duration<br>  MaxConns <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServer</span><span class="hljs-params">(cfg *ServerConfig)</span> *<span class="hljs-title">Server</span></span> &#123;<br>  <span class="hljs-keyword">return</span> &amp;Server&#123;Addr: cfg.Addr, Port: cfg.Port, Timeout: cfg.Timeout, MaxConns: cfg.MaxConns&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如何设计上面对象的构造函数，我们有几种不同的方式。</p><h3 id="参数注入"><a href="#参数注入" class="headerlink" title="参数注入"></a>参数注入</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewDefaultServer</span><span class="hljs-params">(addr <span class="hljs-keyword">string</span>, port <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">Server</span></span> &#123;<br>  <span class="hljs-keyword">return</span> &amp;Server&#123;Addr: addr, Port: port&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServerWithTimeout</span><span class="hljs-params">(addr <span class="hljs-keyword">string</span>, port <span class="hljs-keyword">int</span>, timeout time.Duration)</span> *<span class="hljs-title">Server</span></span> &#123;<br>  <span class="hljs-keyword">return</span> &amp;Server&#123;Addr: addr, Port: port, Timeout: timeout&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServerWithTimeoutAndMaxConns</span><span class="hljs-params">(addr <span class="hljs-keyword">string</span>, port <span class="hljs-keyword">int</span>, timeout time.Duration, maxConns <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">Server</span></span> &#123;<br>  <span class="hljs-keyword">return</span> &amp;Server&#123;Addr: addr, Port: port, Timeout: timeout, MaxConns: maxConns&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Go不支持重载，所以这样的构造函数设计对Go编程非常的不友好。</p><h3 id="Config配置"><a href="#Config配置" class="headerlink" title="Config配置"></a>Config配置</h3><p>将非必要参数放在<code>Config</code>对象中，并且将<code>Config</code>对象传入<code>Server</code>对象中，这是比较常见的用法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Server <span class="hljs-keyword">struct</span> &#123;<br>  Addr <span class="hljs-keyword">string</span><br>  Port <span class="hljs-keyword">int</span><br>  Cfg  *ServerConfig<br>&#125;<br><br><span class="hljs-keyword">type</span> ServerConfig <span class="hljs-keyword">struct</span> &#123;<br>  Timeout  time.Duration<br>  MaxConns <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServer</span><span class="hljs-params">(addr <span class="hljs-keyword">string</span>, port <span class="hljs-keyword">int</span>, cfg *ServerConfig)</span> *<span class="hljs-title">Server</span></span> &#123;<br>  <span class="hljs-keyword">return</span> &amp;Server&#123;Addr: addr, Port: port, Cfg: cfg&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  srv := NewServer(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>, &amp;ServerConfig&#123;Timeout: time.Second&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>这样设计的有一个不好的点：Config不是必须的参数，那么去使用Config对象的时候，需要去判断是否是nil或者Empty。</p><h3 id="Builder配置"><a href="#Builder配置" class="headerlink" title="Builder配置"></a>Builder配置</h3><p><code>builder</code>模式是大家比较熟悉的设计模式了。我们也已经使用<code>builder</code>模式去构造对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ServerBuilder <span class="hljs-keyword">struct</span> &#123;<br>  *Server<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Create</span><span class="hljs-params">(addr <span class="hljs-keyword">string</span>, port <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">ServerBuilder</span></span> &#123;<br>  <span class="hljs-keyword">return</span> &amp;ServerBuilder&#123;&amp;Server&#123;Addr: addr, Port: port&#125;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(builder *ServerBuilder)</span> <span class="hljs-title">WithTimeout</span><span class="hljs-params">(timeout time.Duration)</span> *<span class="hljs-title">ServerBuilder</span></span> &#123;<br>  builder.Timeout = timeout<br>  <span class="hljs-keyword">return</span> builder<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(builder *ServerBuilder)</span> <span class="hljs-title">WithMaxConns</span><span class="hljs-params">(maxConns <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">ServerBuilder</span></span> &#123;<br>  builder.MaxConns = maxConns<br>  <span class="hljs-keyword">return</span> builder<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(builder *ServerBuilder)</span> <span class="hljs-title">Build</span><span class="hljs-params">()</span> *<span class="hljs-title">Server</span></span> &#123;<br>  <span class="hljs-keyword">return</span> builder.Server<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  srv := Create(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>).WithTimeout(time.Second).WithMaxConns(<span class="hljs-number">100</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>也可以直接在<code>Server</code>对象上使用<code>builder</code>模式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(addr <span class="hljs-keyword">string</span>, port <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">Server</span></span> &#123;<br>  <span class="hljs-keyword">return</span> &amp;Server&#123;Addr: addr, Port: port&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *Server)</span> <span class="hljs-title">WithTimeout</span><span class="hljs-params">(timeout time.Duration)</span> *<span class="hljs-title">Server</span></span> &#123;<br>  srv.Timeout = timeout<br>  <span class="hljs-keyword">return</span> srv<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *Server)</span> <span class="hljs-title">WithMaxConns</span><span class="hljs-params">(maxConns <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">Server</span></span> &#123;<br>  srv.MaxConns = maxConns<br>  <span class="hljs-keyword">return</span> srv<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  srv := NewServer(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>).WithTimeout(time.Second).WithMaxConns(<span class="hljs-number">100</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>builder</code>模式的代码就漂亮整洁很多了。</p><p>但是这个模式不太好去处理构造过程中的<code>error</code>。</p><h3 id="Functions-Options设计"><a href="#Functions-Options设计" class="headerlink" title="Functions Options设计"></a>Functions Options设计</h3><p><code>function options</code>是Go中最常见的设计模式，这也是我们极力推崇的模式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ServerOption <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Server)</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ServerTimeoutOption</span><span class="hljs-params">(timeout time.Duration)</span> <span class="hljs-title">ServerOption</span></span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(srv *Server)</span></span> &#123; srv.Timeout = timeout &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ServerMaxConns</span><span class="hljs-params">(maxConns <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">ServerOption</span></span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(srv *Server)</span></span> &#123; srv.MaxConns = maxConns &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewServer</span><span class="hljs-params">(addr <span class="hljs-keyword">string</span>, port <span class="hljs-keyword">int</span>, opts ...ServerOption)</span> <span class="hljs-params">(*Server, error)</span></span> &#123;<br>  srv := Server&#123;<br>    Addr:     addr,<br>    Port:     port,<br>    Timeout:  time.Second,<br>    MaxConns: <span class="hljs-number">1000</span>,<br>  &#125;<br>  <span class="hljs-keyword">for</span> _, option := <span class="hljs-keyword">range</span> opts &#123;<br>    option(&amp;srv)<br>  &#125;<br>  <span class="hljs-comment">// do something</span><br>  <span class="hljs-keyword">return</span> &amp;srv, <span class="hljs-literal">nil</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  srv, err := NewServer(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>, ServerTimeoutOption(time.Second), ServerMaxConns(<span class="hljs-number">100</span>))<br>&#125;<br><br></code></pre></td></tr></table></figure><p>关于这种模式有以下几点好处：</p><ul><li><p>  没有可选配置困扰</p></li><li><p>  支持默认值选项</p></li><li><p>  容易扩展维护</p></li></ul><p>这就是我们强烈推荐的<code>Functional Options</code>设计模式。希望大家可以多多实践这种模式，非常香。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>go工程-Dockefile实践</title>
    <link href="/2022/07/15/go%E5%B7%A5%E7%A8%8B-Dockefile%E5%AE%9E%E8%B7%B5/"/>
    <url>/2022/07/15/go%E5%B7%A5%E7%A8%8B-Dockefile%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<p>在项目工程中，最重要的一环就是部署。而Docker容器部署是最方便我们去管理服务应用的。</p><span id="more"></span><p>接下来我们实践一个标准的Go Web Dockerfile。</p><p>一般容器构建，我们都会分划分为两个阶段，一个是构建阶段，一个是部署阶段。</p><p>Docker是支持多阶段构建的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"># 阶段一：构建阶段<br>FROM golang:<span class="hljs-number">1.16</span>-alpine3<span class="hljs-number">.12</span> AS build<br><br># 设置环境变量<br>ENV GOPROXY=https:<span class="hljs-comment">//goproxy.cn,direct</span><br>ENV GO111MODULE=auto<br>ENV CGO_ENABLED=<span class="hljs-number">0</span><br>ENV GOOS=linux<br><br>ARG PROJECT_NAME<br>ARG LDFLAGS=<span class="hljs-string">&quot;-s -w -linkmode external -extldflags \&quot;-static\&quot;&quot;</span><br><br>WORKDIR /<span class="hljs-keyword">go</span>/src/$&#123;PROJECT_NAME&#125;<br><br>RUN sed -i <span class="hljs-string">&#x27;s!http://dl-cdn.alpinelinux.org/!https://mirrors.tuna.tsinghua.edu.cn/!g&#x27;</span> /etc/apk/repositories<br>RUN apk update &amp;&amp; apk upgrade<br>RUN apk add --no-cache git openssh gcc musl-dev<br><br>COPY . .<br># 下载依赖<br>RUN <span class="hljs-keyword">go</span> mod download<br><br># 编译<br>RUN <span class="hljs-keyword">go</span> build -installsuffix=cgo \<br>    -tags=<span class="hljs-string">&quot;jsoniter netgo&quot;</span> \<br>    -ldflags=<span class="hljs-string">&quot;$LDFLAGS&quot;</span> \<br>    -o=$&#123;PROJECT_NAME&#125; \<br>    /<span class="hljs-keyword">go</span>/src/$&#123;PROJECT_NAME&#125;/cmd/$&#123;PROJECT_NAME&#125;<br><br># 阶段二：部署阶段<br>FROM alpine:<span class="hljs-number">3.12</span><br><br>LABEL author=yang.liu<br>ARG APP_NAME<br>ARG PROJECT_NAME<br><br>ENV APP_NAME $&#123;APP_NAME&#125;<br>ENV PROJECT_NAME $&#123;PROJECT_NAME&#125;<br>ENV TZ=Asia/Shanghai LANG=C.UTF<span class="hljs-number">-8</span> GOPATH=/<span class="hljs-keyword">go</span><br><br>RUN sed -i <span class="hljs-string">&#x27;s!http://dl-cdn.alpinelinux.org/!https://mirrors.tuna.tsinghua.edu.cn/!g&#x27;</span> /etc/apk/repositories<br><br># 设置时区<br>RUN apk --update add ca-certificates tzdata &amp;&amp; \<br>    cp /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; \<br>    echo $TZ &gt; /etc/timezone<br><br>WORKDIR /app<br># 复制构建阶段编译好的可执行文件到部署容器中<br>COPY --from=build /<span class="hljs-keyword">go</span>/src/$&#123;PROJECT_NAME&#125;/$&#123;PROJECT_NAME&#125; ./$&#123;PROJECT_NAME&#125;/<br><br>CMD /app/$&#123;PROJECT_NAME&#125;/$&#123;PROJECT_NAME&#125;<br><br></code></pre></td></tr></table></figure><p>构建命令：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">docker build --build-arg APP_NAME=应用名 --build-arg PROJECT_NAME=项目名  -f Dockerfile文件未知 -t 镜像名 .<br></code></pre></td></tr></table></figure><p>这是我们内部实践的标准Dockerfile（需要符合内部规范的工程目录）。</p><p>如果存在内部项目依赖问题，可以申请git token配置_netrc文件去解决项目依赖问题。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>go工程-单元测试之gomock</title>
    <link href="/2022/07/12/go%E5%B7%A5%E7%A8%8B-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8Bgomock/"/>
    <url>/2022/07/12/go%E5%B7%A5%E7%A8%8B-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B9%8Bgomock/</url>
    
    <content type="html"><![CDATA[<p>在开发中，我们需要编写很多测试代码去保证我们代码的健壮性。</p><p>如果一个对象中有大量的接口依赖的时候，我们往往无法注入真实的接口对象，这个时候就是gomock大显身手的时候了。</p><span id="more"></span><p><a href="https://github.com/golang/mock" title="gomock"><strong>gomock</strong></a> 是官方提供的 mock 框架，同时还提供了 mockgen 工具用来辅助生成测试代码。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>go version &lt; 1.16</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">GO111MODULE=on <span class="hljs-keyword">go</span> get github.com/golang/mock/mockgen@v1<span class="hljs-number">.6</span><span class="hljs-number">.0</span><br></code></pre></td></tr></table></figure><p>go version 1.16+</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> install github.com/golang/mock/mockgen@v1<span class="hljs-number">.6</span><span class="hljs-number">.0</span><br></code></pre></td></tr></table></figure><p>这里会将<code>mockgen</code>工具添加到<code>$GOPATH/bin</code>下，如果想要使用，请确保<code>$GOPATH/bin</code>已经添加在<code>$PATH</code>下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"># mockgen -h<br>mockgen has two modes of operation: source and reflect.<br><br>Source mode generates mock interfaces from a source file.<br>It is enabled by using the -source flag. Other flags that<br>may be useful in this mode are -imports and -aux_files.<br>Example:<br>  mockgen -source=foo.<span class="hljs-keyword">go</span> [other options]<br><br>Reflect mode generates mock interfaces by building a program<br>that uses reflection to understand interfaces. It is enabled<br>by passing two non-flag arguments: an <span class="hljs-keyword">import</span> path, and a<br>comma-separated list of symbols.<br>Example:<br>  mockgen database/sql/driver Conn,Driver<br><br>  -aux_files <span class="hljs-keyword">string</span><br>      (source mode) Comma-separated pkg=path pairs of auxiliary Go source files.<br>  -build_flags <span class="hljs-keyword">string</span><br>      (reflect mode) Additional flags <span class="hljs-keyword">for</span> <span class="hljs-keyword">go</span> build.<br>  -copyright_file <span class="hljs-keyword">string</span><br>      Copyright file used to add copyright header<br>  -debug_parser<br>      Print out parser results only.<br>  -destination <span class="hljs-keyword">string</span><br>      Output file; defaults to stdout.<br>  -exec_only <span class="hljs-keyword">string</span><br>      (reflect mode) If set, execute this reflection program.<br>  -imports <span class="hljs-keyword">string</span><br>      (source mode) Comma-separated name=path pairs of explicit imports to use.<br>  -mock_names <span class="hljs-keyword">string</span><br>      Comma-separated interfaceName=mockName pairs of explicit mock names to use. Mock names <span class="hljs-keyword">default</span> to <span class="hljs-string">&#x27;Mock&#x27;</span>+ interfaceName suffix.<br>  -<span class="hljs-keyword">package</span> <span class="hljs-keyword">string</span><br>      Package of the generated code; defaults to the <span class="hljs-keyword">package</span> of the input with a <span class="hljs-string">&#x27;mock_&#x27;</span> prefix.<br>  -prog_only<br>      (reflect mode) Only generate the reflection program; write it to stdout and exit.<br>  -self_package <span class="hljs-keyword">string</span><br>      The full <span class="hljs-keyword">package</span> <span class="hljs-keyword">import</span> path <span class="hljs-keyword">for</span> the generated code. The purpose of this flag is to prevent <span class="hljs-keyword">import</span> cycles in the generated code by trying to include its own <span class="hljs-keyword">package</span>. This can happen <span class="hljs-keyword">if</span> the mock<span class="hljs-string">&#x27;s package is set to one of its inputs (usually the main one) and the output is stdio so mockgen cannot detect the final output package. Setting this flag will then tell mockgen which import to exclude.</span><br><span class="hljs-string">  -source string</span><br><span class="hljs-string">      (source mode) Input Go source file; enables source mode.</span><br><span class="hljs-string">  -version</span><br><span class="hljs-string">      Print version.</span><br><span class="hljs-string">  -write_package_comment</span><br><span class="hljs-string">      Writes package documentation comment (godoc) if true. (default true)</span><br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在mockgen中，支持两种生成模式：</p><ol><li> source：从源文件生成mock接口</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">mockgen -source=foo.<span class="hljs-keyword">go</span> [other options]<br></code></pre></td></tr></table></figure><p>&#x20; 2. reflect：通过使用反射程序来生成mock接口。它通过传递两个非标志参数来启用：导入路径和逗号分隔的接口列表。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">mockgen database/sql/driver Conn,Driver<br><br></code></pre></td></tr></table></figure><p>从本质上来讲，两种方式生成的mock代码并没有什么区别。因此选择合适的就可以了。</p><p>mockgen工具可以帮助我们自动生成接口的打桩代码。</p><ul><li><p>  -source：设置需要mock的接口文件。</p></li><li><p>  -destination：设置mock的接口文件输出的地方，默认打印在标准输出中。</p></li><li><p>  -package：设置mock输出文件的包名，默认是****加上文件名。</p></li></ul><p>以<a href="https://github.com/lyouthzzz/go-web-layout/blob/main/internal/domain/order/order.go" title="order.go"><strong>order.go</strong></a>为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//go:generate mockgen -source order.go -destination ../../mock/domain/order/order_mock.go -package=order</span><br><br><span class="hljs-keyword">type</span> IOrderClient <span class="hljs-keyword">interface</span> &#123;<br>  GetOrder(context.Context, <span class="hljs-keyword">uint</span>) (*Order, error)<br>&#125;<br></code></pre></td></tr></table></figure><p>执行下面命令可以将internal/domain/order/order.go的接口mock代码输出到internal/mock/domain/order/order_mock.go，包名是order：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">mockgen -source internal/domain/order/order.<span class="hljs-keyword">go</span> -destination internal/mock/domain/order/order_mock.<span class="hljs-keyword">go</span> -<span class="hljs-keyword">package</span>=order<br></code></pre></td></tr></table></figure><p>我们可以定义<code>//go:generate</code>命令，然后执行<code>go generate ./...</code>可以自动生成打桩代码到指定目录。</p><h2 id="打桩代码"><a href="#打桩代码" class="headerlink" title="打桩代码"></a>打桩代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// MockIOrderClient is a mock of IOrderClient interface.</span><br><span class="hljs-keyword">type</span> MockIOrderClient <span class="hljs-keyword">struct</span> &#123;<br>  ctrl     *gomock.Controller<br>  recorder *MockIOrderClientMockRecorder<br>&#125;<br><br><span class="hljs-comment">// MockIOrderClientMockRecorder is the mock recorder for MockIOrderClient.</span><br><span class="hljs-keyword">type</span> MockIOrderClientMockRecorder <span class="hljs-keyword">struct</span> &#123;<br>  mock *MockIOrderClient<br>&#125;<br><br><span class="hljs-comment">// NewMockIOrderClient creates a new mock instance.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewMockIOrderClient</span><span class="hljs-params">(ctrl *gomock.Controller)</span> *<span class="hljs-title">MockIOrderClient</span></span> &#123;<br>  mock := &amp;MockIOrderClient&#123;ctrl: ctrl&#125;<br>  mock.recorder = &amp;MockIOrderClientMockRecorder&#123;mock&#125;<br>  <span class="hljs-keyword">return</span> mock<br>&#125;<br><br><span class="hljs-comment">// EXPECT returns an object that allows the caller to indicate expected use.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MockIOrderClient)</span> <span class="hljs-title">EXPECT</span><span class="hljs-params">()</span> *<span class="hljs-title">MockIOrderClientMockRecorder</span></span> &#123;<br>  <span class="hljs-keyword">return</span> m.recorder<br>&#125;<br><br><span class="hljs-comment">// GetOrder mocks base method.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MockIOrderClient)</span> <span class="hljs-title">GetOrder</span><span class="hljs-params">(arg0 context.Context, arg1 <span class="hljs-keyword">uint</span>)</span> <span class="hljs-params">(*order.Order, error)</span></span> &#123;<br>  m.ctrl.T.Helper()<br>  ret := m.ctrl.Call(m, <span class="hljs-string">&quot;GetOrder&quot;</span>, arg0, arg1)<br>  ret0, _ := ret[<span class="hljs-number">0</span>].(*order.Order)<br>  ret1, _ := ret[<span class="hljs-number">1</span>].(error)<br>  <span class="hljs-keyword">return</span> ret0, ret1<br>&#125;<br><br><span class="hljs-comment">// GetOrder indicates an expected call of GetOrder.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mr *MockIOrderClientMockRecorder)</span> <span class="hljs-title">GetOrder</span><span class="hljs-params">(arg0, arg1 <span class="hljs-keyword">interface</span>&#123;&#125;)</span> *<span class="hljs-title">gomock</span>.<span class="hljs-title">Call</span></span> &#123;<br>  mr.mock.ctrl.T.Helper()<br>  <span class="hljs-keyword">return</span> mr.mock.ctrl.RecordCallWithMethodType(mr.mock, <span class="hljs-string">&quot;GetOrder&quot;</span>, reflect.TypeOf((*MockIOrderClient)(<span class="hljs-literal">nil</span>).GetOrder), arg0, arg1)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>参数（Eq, Any, Not, Nil）</p><ul><li><p>  <code>Eq(value)</code> 表示与 value 等价的值。</p></li><li><p>  <code>Any()</code> 可以用来表示任意的入参。</p></li><li><p>  <code>Not(value)</code> 用来表示非 value 以外的值。</p></li><li><p>  <code>Nil()</code> 表示 nil 值</p></li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">orderClient.EXPECT().GetOrder(gomock.Eq(context.Background()), gomock.Any()).Return(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>)<br>orderClient.EXPECT().GetOrder(gomock.Eq(context.Background()), gomock.Not(<span class="hljs-keyword">uint</span>(<span class="hljs-number">111</span>))).Return(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>)<br><br></code></pre></td></tr></table></figure><ul><li><p>返回值（Return, DoAndReturn）</p><ul><li><p>  <code>Return()</code>。直接返回数据。</p></li><li><p>  <code>DoAndReturn(f interface&#123;&#125;)</code>。f的函数签名和接口保持一致。</p></li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">orderClient.EXPECT().GetOrder(gomock.Any(), gomock.Eq(<span class="hljs-keyword">uint</span>(<span class="hljs-number">111</span>))).Return(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>)<br>orderClient.EXPECT().GetOrder(gomock.Eq(context.Background()), gomock.Not(<span class="hljs-keyword">uint</span>(<span class="hljs-number">111</span>))).DoAndReturn(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, id <span class="hljs-keyword">uint</span>)</span> <span class="hljs-params">(*orderdomain.Order, error)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> id == <span class="hljs-number">1111</span> &#123;<br>      fmt.Println(<span class="hljs-string">&quot;1111&quot;</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      fmt.Println(id)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>  &#125;)<br></code></pre></td></tr></table></figure><ul><li><p>调用次数（Times）</p><ul><li><p>  <code>Times()</code> 断言 Mock 方法被调用的次数。</p></li><li><p>  <code>MaxTimes()</code> 最大次数。</p></li><li><p>  <code>MinTimes()</code> 最小次数。</p></li><li><p>  <code>AnyTimes()</code> 任意次数（包括 0 次）。</p></li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">orderClient.EXPECT().GetOrder(gomock.Any(), gomock.Eq(<span class="hljs-keyword">uint</span>(<span class="hljs-number">111</span>))).Return(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>).AnyTimes()<br></code></pre></td></tr></table></figure><ul><li>  调用顺序（InOrder）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">gomock.InOrder(<br>  orderClient.EXPECT().GetOrder(gomock.Any(), gomock.Any()).Return(o, <span class="hljs-literal">nil</span>),<br>  orderClient.EXPECT().GetOrder(gomock.Any(), gomock.Eq(<span class="hljs-keyword">uint</span>(<span class="hljs-number">1</span>))).Return(o, retErr).AnyTimes(),<br>)<br></code></pre></td></tr></table></figure><p>第一次调用会返回o, nil</p><p>第二次调用会返回o, retErr</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>接下来写一个order_test.go来看一下如何使用mock文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestUsecase_GetOrder</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>ctl := gomock.NewController(t)<br>  <span class="hljs-keyword">defer</span> ctl.Finish()<br>  orderClient := order.NewMockIOrderClient(ctl)<br>  orderUc := NewOrderUsecase(orderClient)<br><br>  o := &amp;orderdomain.Order&#123;Id: <span class="hljs-number">1</span>, OrderName: <span class="hljs-string">&quot;name&quot;</span>&#125;<br>  retErr := errors.New(<span class="hljs-string">&quot;order: not found&quot;</span>)<br>  gomock.InOrder(<br>    orderClient.EXPECT().GetOrder(gomock.Any(), gomock.Any()).Return(o, <span class="hljs-literal">nil</span>),<br>    orderClient.EXPECT().GetOrder(gomock.Any(), gomock.Eq(<span class="hljs-keyword">uint</span>(<span class="hljs-number">1</span>))).Return(o, retErr).AnyTimes(),<br>  )<br><br>  _order, err := orderUc.GetOrder(context.Background(), <span class="hljs-keyword">uint</span>(<span class="hljs-number">1</span>))<br>  require.NoError(t, err)<br>  require.Equal(t, o, _order)<br><br>  _order, err = orderUc.GetOrder(context.Background(), <span class="hljs-keyword">uint</span>(<span class="hljs-number">1</span>))<br>  require.Equal(t, retErr, err)<br>  require.Equal(t, o, _order)<br><br>  _order, err = orderUc.GetOrder(context.Background(), <span class="hljs-keyword">uint</span>(<span class="hljs-number">1</span>))<br>  require.Equal(t, retErr, err)<br>  require.Equal(t, o, _order)<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p> 实例化gomock controller对象。</p></li><li><p> 实例化IOrderClient对象。</p></li><li><p> 设置IOrderClient.GetOrder的入参和出参，入参可以使用Matcher对象设置匹配规则，匹配规则后会返回出参，否则会报错。</p></li><li><p> 调用OrderUsecase方法。</p></li></ol><p>这样我们就简单完成了OrderUsecase的单元测试了。</p><p>在单元测试中，gomock给我们提供了极大的便利。我们可以mock掉许多复杂的依赖，做很多的测试用例来保证业务的正确性。</p><h2 id="examples"><a href="#examples" class="headerlink" title="examples"></a>examples</h2><ul><li>  <a href="https://github.com/lyouthzzz/go-web-layout" title="go-web-layout"><strong>go-web-layout</strong></a></li></ul><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ul><li>  <a href="https://github.com/golang/mock" title="https://github.com/golang/mock">https://github.com/golang/mock</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>go工程-依赖注入工具wire</title>
    <link href="/2022/07/10/go%E5%B7%A5%E7%A8%8B-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7wire/"/>
    <url>/2022/07/10/go%E5%B7%A5%E7%A8%8B-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%B7%A5%E5%85%B7wire/</url>
    
    <content type="html"><![CDATA[<p>在一个应用程序中，我们需要创建很多对象，也需要去管理这些对象的依赖关系。</p><span id="more"></span><p>随着复杂业务的变化，这些对象的创建及依赖关系也会发生很大的改变，这时候开发人员管理起来有些力不从心。</p><p>为了解决这些痛点，Go Cloud团队开发了一个轻巧的Golang依赖注入工具<a href="https://github.com/google/wire" title="wire"><strong>wire</strong></a>，可以通过自动生成代码的方式在编译期完成依赖注入。</p><h2 id="什么是wire"><a href="#什么是wire" class="headerlink" title="什么是wire"></a>什么是wire</h2><p><a href="https://github.com/google/wire" title="wire"><strong>wire</strong></a>是一个代码生成工具，<a href="https://github.com/google/wire" title="wire"><strong>wire</strong></a>可以生成Go源码并在编译期完成依赖注入。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go install github.com/google/wire/cmd/wire@latest<br></code></pre></td></tr></table></figure><p>这里会将wire工具添加到<code>$GOPATH/bin</code>下，如果想要使用，请确保<code>$GOPATH/bin</code>已经添加在<code>$PATH</code>下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">wire -h<br>Usage: wire &lt;flags&gt; &lt;subcommand&gt; &lt;subcommand args&gt;<br><br>Subcommands:<br>  check            <span class="hljs-built_in">print</span> any Wire errors found<br>  commands         list all <span class="hljs-built_in">command</span> names<br>  diff             output a diff between existing wire_gen.go files and what gen would generate<br>  flags            describe all known top-level flags<br>  gen              generate the wire_gen.go file <span class="hljs-keyword">for</span> each package<br>  <span class="hljs-built_in">help</span>             describe subcommands and their syntax<br>  show             describe all top-level provider sets<br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>一般我们手动注入是这么做的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> (<br>  A <span class="hljs-keyword">struct</span> &#123;<br>    B *B<br>    C *C<br>    D *D<br>  &#125;<br>  B <span class="hljs-keyword">struct</span>&#123;&#125;<br>  C <span class="hljs-keyword">struct</span>&#123;&#125;<br>  D <span class="hljs-keyword">struct</span>&#123;&#125;<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewA</span><span class="hljs-params">(b *B, c *C, d *D)</span> *<span class="hljs-title">A</span></span> &#123;<br>  <span class="hljs-keyword">return</span> &amp;A&#123;b, c, d&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewB</span><span class="hljs-params">()</span> *<span class="hljs-title">B</span></span> &#123;<br>  <span class="hljs-keyword">return</span> &amp;B&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewC</span><span class="hljs-params">()</span> *<span class="hljs-title">C</span></span> &#123;<br>  <span class="hljs-keyword">return</span> &amp;C&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewD</span><span class="hljs-params">()</span> *<span class="hljs-title">D</span></span> &#123;<br>  <span class="hljs-keyword">return</span> &amp;D&#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>初始化对象并且设置依赖关系：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WireA</span><span class="hljs-params">()</span> *<span class="hljs-title">A</span></span> &#123;<br>  b := NewB()<br>  c := NewC()<br>  d := NewD()<br>  <span class="hljs-keyword">return</span> NewA(b, c, d)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里只有些许对象的依赖，随着项目复杂度的提升，对象的初始化，以及手动依赖注入会变的越来越复杂。</p><p>我们接下来会去使用wire的方式去改造这些流程。</p><p>wire中有一个Provider的概念，代表的是一个对象的构造方法。比如NewA()、NewB()等。</p><p>当想要管理多个Provider的时候，那么可以使用ProviderSet。</p><ol><li> 加入了一个ProviderSet对象去管理对象的构造函数（顺序没有强制要求）。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ProviderSet = wire.NewSet(NewB, NewC, NewD, NewA)<br></code></pre></td></tr></table></figure><p>2. 新建一个<code>wire.go</code>文件。由于<code>wire.go</code>中的函数并没有真正返回值，为避免编译器报错， 简单地用<code>panic</code>函数包装起来即可。不用担心执行时报错， 因为它不会实际运行，只是用来生成真正的代码的依据。</p><p>需要加入头信息 <code>// +build wireinject</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// +build wireinject</span><br><br><span class="hljs-keyword">package</span> wire<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/google/wire&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WireA</span><span class="hljs-params">()</span> *<span class="hljs-title">A</span></span> &#123;<br>  <span class="hljs-built_in">panic</span>(wire.Build(ProviderSet))<br>&#125;<br></code></pre></td></tr></table></figure><p>3. 在当前目录执行 <code>wire</code> 命令，会生成新的<code>wire_gen.go</code>文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Code generated by Wire. DO NOT EDIT.</span><br><br><span class="hljs-comment">//go:generate go run github.com/google/wire/cmd/wire</span><br><span class="hljs-comment">//+build !wireinject</span><br><br><span class="hljs-keyword">package</span> wire<br><br><span class="hljs-comment">// Injectors from wire.go:</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WireA</span><span class="hljs-params">()</span> *<span class="hljs-title">A</span></span> &#123;<br>  b := NewB()<br>  c := NewC()<br>  d := NewD()<br>  a := NewA(b, c, d)<br>  <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现，<code>wire</code>做的就是上面我们手动编写的代码。</p><p>对象越多，依赖越复杂，<code>wire</code>的好处就越明显。</p><p>下面讲一些使用技巧：</p><ul><li><p>  执行wire命令后，wire会通过构造函数生成对象，并且将对象注入别的所需要的构造函数去。</p></li><li><p>  构造函数不支持两个或更多的类型相同的入参。因为wire无法知道注入的顺序如何，会导致不可知的错误。如果有两个或多个类型的参数，会报错 <code>provider has multiple parameters of type</code>。</p></li><li><p>  <code>wire.Struct(new(A), &quot;\*&quot;)</code>可以将provider初始化的对象通过属性注入到A对象中。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ProviderSet = wire.NewSet(NewB, NewC, NewD, wire.Struct(<span class="hljs-built_in">new</span>(A), <span class="hljs-string">&quot;*&quot;</span>))<br></code></pre></td></tr></table></figure><p>生成的<code>wire\_gen.go</code>文件如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Code generated by Wire. DO NOT EDIT.</span><br><br><span class="hljs-comment">//go:generate go run github.com/google/wire/cmd/wire</span><br><span class="hljs-comment">//+build !wireinject</span><br><br><span class="hljs-keyword">package</span> wire<br><br><span class="hljs-comment">// Injectors from wire.go:</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WireA</span><span class="hljs-params">()</span> *<span class="hljs-title">A</span></span> &#123;<br>  b := NewB()<br>  c := NewC()<br>  d := NewD()<br>  a := &amp;A&#123;<br>    B: b,<br>    C: c,<br>    D: d,<br>  &#125;<br>  <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，我们也可以通过属性名去选择字段去注入。等同于上面。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ProviderSet = wire.NewSet(NewB, NewC, NewD, wire.Struct(<span class="hljs-built_in">new</span>(A), <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>))<br></code></pre></td></tr></table></figure><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><ul><li>  <a href="https://github.com/lyouthzzz/go-web-layout/blob/main/cmd/go-web-layout/wire.go" title="go-web-layout"><strong>go-web-layout</strong></a></li></ul><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ul><li><p>  <a href="https://github.com/google/wire" title="https://github.com/google/wire">https://github.com/google/wire</a></p></li><li><p>  <a href="https://zhuanlan.zhihu.com/p/110453784" title="https://zhuanlan.zhihu.com/p/110453784">https://zhuanlan.zhihu.com/p/110453784</a></p></li><li><p>  <a href="https://medium.com/@dche423/master-wire-cn-d57de86caa1b" title="https://medium.com/@dche423/master-wire-cn-d57de86caa1b">https://medium.com/@dche423/master-wire-cn-d57de86caa1b</a></p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>再谈Go工程目录</title>
    <link href="/2022/07/09/%E5%86%8D%E8%B0%88Go%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95/"/>
    <url>/2022/07/09/%E5%86%8D%E8%B0%88Go%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>为了提高程序的可读性与可维护性，我们应该为软件设计良好的目录结构，这与规范的编码风格同等重要。</p><span id="more"></span><p>在go中，社区定义了Go应用程序项目的基本布局，大家可自行链接<a href="https://github.com/golang-standards/project-layout" title="project-layout"><strong>project-layout</strong></a>。它不是核心Go开发团队定义的官方标准，但是它是Go生态一些常见项目的布局模式，并且是受大家认可推崇的布局。</p><p><a href="https://github.com/golang-standards/project-layout" title="project-layout"><strong>project-layout</strong></a>为我们提供了整体布局，但是未提供开发者设计更详细的分层布局。接下来我会详细讲讲如何去设计分层，去支持应用复杂的开发任务。</p><p>由于我们团队内部使用的是<a href="https://github.com/go-kratos/kratos" title="kratos"><strong>kratos</strong></a>微服务框架接，所以我们会基于<a href="https://github.com/go-kratos/kratos" title="kratos"><strong>kratos</strong></a>社区推崇的目录来讲一讲我们团队对于该工程目录实践的一些思考。</p><h2 id="工程目录"><a href="#工程目录" class="headerlink" title="工程目录"></a>工程目录</h2><h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><ul><li><p>  定义proto IDL文件。</p></li><li><p>  定义errors.proto文件。管理服务错误码。</p></li><li><p>  定义service.proto文件。管理服务接口定义。</p></li></ul><h3 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h3><ul><li><p>  项目APP的入口，启动服务的地方。</p></li><li><p>  每个应用程序的目录名应该与你想要的可执行文件的名称相匹配。</p></li><li><p>  通常有一个小的 <code>main</code> 函数，从 <code>/internal</code> 和 <code>/pkg</code> 目录导入和调用代码，除此之外没有别的东西。</p></li></ul><h3 id="configs"><a href="#configs" class="headerlink" title="configs"></a>configs</h3><ul><li>  定义配置文件。</li></ul><h3 id="deployments"><a href="#deployments" class="headerlink" title="deployments"></a>deployments</h3><ul><li>  定义服务部署文件。（例如<code>Dockerfile</code>、<code>docker-compose.yaml</code>、<code>kubernetes.service.yaml</code>）。</li></ul><h3 id="docs"><a href="#docs" class="headerlink" title="docs"></a>docs</h3><ul><li>  管理项目文档。</li></ul><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><ul><li>  管理项目测试代码。</li></ul><h3 id="pkg"><a href="#pkg" class="headerlink" title="pkg"></a>pkg</h3><ul><li><p>  外部应用程序可以使用的库代码。(例如 <code>/pkg/mypubliclib</code>)。</p></li><li><p>  放置一些项目内或者跨应用的共同可用的代码。</p></li></ul><h3 id="internal"><a href="#internal" class="headerlink" title="internal"></a>internal</h3><p>internal目录是我们重点设计目录。</p><h4 id="server"><a href="#server" class="headerlink" title="server"></a>server</h4><ul><li>  注册服务api，构建以及<code>HTTP</code>和<code>gRPC</code>服务实例。</li></ul><h4 id="service"><a href="#service" class="headerlink" title="service"></a>service</h4><ul><li><p>  实现api层proto定义的service interface。</p></li><li><p>  编排biz层的usecase对象。</p></li></ul><h4 id="biz"><a href="#biz" class="headerlink" title="biz"></a>biz</h4><ul><li><p>  biz开发<code>usecase</code>对象。负责具体业务的实现。</p></li><li><p>  依赖<code>domain</code>定义的<code>interface</code>（例如 <code>FacadeInterface</code>、<code>RepoInterface</code>等）。</p></li><li><p>  <code>usecase</code>之间不可以相互依赖。业务是独立的，依赖会导致耦合。一个业务迭代的变更不应该影响到别的业务。</p></li></ul><h4 id="domain"><a href="#domain" class="headerlink" title="domain"></a>domain</h4><ul><li><p>  不依赖任何别的package。</p></li><li><p>  负责外部定义接口（比如<code>FacadeInterface</code>、<code>RepoInterface</code>）以及相关的DTO对象。</p></li><li><p>  负责业务错误码的定义。</p></li><li><p>  负责<code>DO</code>对象（<code>domain object</code>）以及<code>ADO</code>（<code>aggregate domain object</code>）的定义。</p></li></ul><h4 id="facade"><a href="#facade" class="headerlink" title="facade"></a>facade</h4><ul><li>  防腐层设计。实现<code>domain</code>的<code>FacadeInterface</code>，和外部接口交互。</li></ul><h4 id="mock"><a href="#mock" class="headerlink" title="mock"></a>mock</h4><ul><li>  mock domain层接口。方便做<code>biz</code>层<code>usecase</code>对象的单元测试。</li></ul><h4 id="data"><a href="#data" class="headerlink" title="data"></a>data</h4><ul><li><p>  实现domain层定义的数据相关的接口（比如<code>RepoInterface</code>）。</p></li><li><p>  和数据层交互（比如<code>mq</code>、<code>db</code>、<code>cache</code>）。</p></li><li><p>  负责<code>PO</code>（<code>persistent object</code>）对象的定义。</p></li></ul><p>之前有写过一篇关于工程目录的文章<a href="https://younman.com/2022/02/19/%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95%E8%AE%BE%E8%AE%A1/" title="工程目录设计"><strong>工程目录设计</strong></a>。层级目录设计以及之间的依赖如下图：</p><p><img src="/images/%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95%E8%AE%BE%E8%AE%A1%E6%B5%81%E8%BD%AC%E5%9B%BE.jpg" alt="工程目录设计-版本1"></p><p>具体结构文件如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── internal<br>│   ├── service<br>│   │   ├── service.go<br>│   │   └── user.go<br>│   ├── data<br>│   │   ├── data.go<br>│   │   ├── model<br>│   │   │   └── user.go<br>│   │   └── user.go<br>│   ├── domain<br>│   │   └── user.go<br>│   ├── facade<br>│   │   └── facade.go<br>│   ├── server<br>│   │   ├── grpc.go<br>│   │   ├── http.go<br>│   │   └── server.go<br>│   └── biz<br>│       ├── biz.go<br>│       └── user.go<br></code></pre></td></tr></table></figure><p>我们以前的做法是将RepoInterface、Errors、定义在biz层，为了是可以让biz层不依赖别的东西，负责聚合完整的业务。目录如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── biz<br>│   ├── biz.go<br>│   └── user_usecase.go<br></code></pre></td></tr></table></figure><p>user.go文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">var ErrUserNotFound = errors.New(<span class="hljs-string">&quot;user: not found&quot;</span>)<br><br><span class="hljs-built_in">type</span> UserRepo interface &#123;<br>  GetUser(ctx context.Context, id uint) (*domain.User, error)<br>&#125;<br><br><span class="hljs-built_in">type</span> UserUsecase struct &#123;<br>  repo UserRepo<br>&#125;<br></code></pre></td></tr></table></figure><p>随着工程慢慢变得复杂，<code>biz</code>层也会慢慢变得复杂，这个时候我们会去根据业务去分包。目录如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── biz<br>│   ├── biz.go<br>│   └── user<br>│       └── usecase.go<br></code></pre></td></tr></table></figure><p>&#x20;随着工程目录的变化就会出现一些问题：</p><ul><li>  循环依赖。比如<code>AUsecase</code>需要依赖<code>BRepoInterface</code>，<code>BUsecase</code>需要依赖<code>ARepoInterface</code>，同样的<code>errors</code>也是如此。这样就会导致循环依赖，编译错误。</li></ul><p>第一版的设计还有一个问题就是，我们允许<code>usecase</code>之间可以相互依赖，当时的想法就是可以复用<code>usecase</code>的代码，并且可以复用<code>usecase</code>抛出来的错误。</p><p>但是后来我们准备去做<code>usecase</code>层单元测试的时候，发现非常的难做。因为如果某个usecase依赖其他<code>usecase</code>，想要做该usecase的单元测试，就需要将依赖的所有的<code>usecase</code>都要做mock。</p><p>后来我们重新思考了DDD的领域设计，最终抛弃了这样的依赖。</p><p>第二版的工程层级目录设计以及之间的依赖如下图：</p><p><img src="/images/%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95%E8%AE%BE%E8%AE%A1-%E7%89%88%E6%9C%AC2.png" alt="工程目录设计-版本2"></p><p>新的版本是由<code>domain</code>层接管<code>biz</code>层的接口以及<code>errors</code>的定义。这样其实<code>biz</code>只需要专注业务就行，并且也不会有以上循环以来的情况出现，因为接口以及errors的定义都放在了<code>domain</code>层。</p><p>具体结构文件如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── internal<br>│   ├── biz<br>│   │   ├── biz.go<br>│   │   ├── order<br>│   │   │   └── order.go<br>│   │   └── user<br>│   │       └── user.go<br>│   ├── conf<br>│   │   ├── conf.pb.go<br>│   │   └── conf.proto<br>│   ├── data<br>│   │   ├── data.go<br>│   │   ├── model<br>│   │   │   └── user.go<br>│   │   └── user.go<br>│   ├── domain<br>│   │   ├── order<br>│   │   │   └── order.go<br>│   │   └── user<br>│   │       └── user.go<br>│   ├── facade<br>│   │   ├── facade.go<br>│   │   └── order<br>│   │       └── client.go<br>│   ├── mock<br>│   │   └── domain<br>│   │       ├── order<br>│   │       └── user<br>│   ├── server<br>│   │   ├── grpc.go<br>│   │   ├── http.go<br>│   │   └── server.go<br>│   └── service<br>│       ├── order.go<br>│       ├── service.go<br>│       └── user.go<br></code></pre></td></tr></table></figure><p>这是新版目录对于之前问题的优化。在内部工程的实践效果也是非常不错的。</p><p>数据流转对象：</p><ul><li><p>  <code>DTO</code>（<code>Data Transfer Objcet</code>）数据传输对象。HTTP/GRPC消息的载体。</p></li><li><p>  <code>DO</code>（<code>Domain Objcet</code>）领域模型。承载业务抽象出来的对象，并包含自身的一些业务逻辑。</p></li><li><p>  <code>PO</code>（<code>Persistent Objcet</code>）持久化对象。数据库建模对象。仅仅包含表名，字段的定义以及主键、外键、索引等表相关的定义。</p></li></ul><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><ul><li>  <a href="https://github.com/lyouthzzz/go-web-layout" title="go-web-layout"><strong>go-web-layout</strong></a></li></ul><p>References</p><ul><li><p>  <a href="https://go-kratos.dev/blog/go-project-layout/" title="https://go-kratos.dev/blog/go-project-layout">https://go-kratos.dev/blog/go-project-layout</a></p></li><li><p>  <a href="https://github.com/golang-standards/project-layout" title="https://github.com/golang-standards/project-layout">https://github.com/golang-standards/project-layout</a></p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何快速部署一些常见的中间件？</title>
    <link href="/2022/06/30/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <url>/2022/06/30/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>分享几个常用的基础中间件服务部署。</p><span id="more"></span><ul><li><p>  mysql</p></li><li><p>  redis</p></li><li><p>  etcd</p></li><li><p>  mongodb</p></li><li><p>  jaeger</p></li></ul><p>可自行从<a href="https://github.com/lyouthzzz/deployments" title="github">github</a>获取。</p><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">version: &#x27;3.7&#x27;<br>services:<br>   mysql:<br>     image: mysql:8.0<br>     restart: on-failure<br>     volumes:<br>       - ./data:/var/lib/mysql<br>     environment:<br>       MYSQL_ROOT_PASSWORD: root<br>     ports:<br>       - 3306:3306<br>     command: <br>       - --character-set-server=utf8mb4<br>       - --collation-server=utf8mb4_unicode_ci<br></code></pre></td></tr></table></figure><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">version: &quot;3.7&quot;<br>services:<br>  redis:<br>    image: &quot;redis&quot;<br>    ports:<br>      - 6379:6379<br>    command:<br>      - --requirepass root<br>      - --bind 0.0.0.0<br></code></pre></td></tr></table></figure><h2 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">version: &quot;3.7&quot;<br>services:<br>  etcdv3:<br>    image: bitnami/etcd:3.5<br>    restart: on-failure<br>    volumes:<br>       - ./data:/bitnami/etcd<br>    environment:<br>      ALLOW_NONE_AUTHENTICATION: &quot;yes&quot;<br>    ports:<br>      - &quot;2379:2379&quot;<br></code></pre></td></tr></table></figure><h2 id="mongodb"><a href="#mongodb" class="headerlink" title="mongodb"></a>mongodb</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">version: &#x27;3.7&#x27;<br>services:<br>  mongo:<br>    image: mongo:4.0.4<br>    restart: on-failure<br>    volumes:<br>      - ./data:/data/db<br>    environment:<br>      MONGO_INITDB_ROOT_USERNAME: &quot;root&quot;<br>      MONGO_INITDB_ROOT_PASSWORD: &quot;root&quot;<br>    ports:<br>      - &quot;27017:27017&quot;<br></code></pre></td></tr></table></figure><h2 id="jaeger"><a href="#jaeger" class="headerlink" title="jaeger"></a>jaeger</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">version: &#x27;3.7&#x27;<br>services:<br>  jaeger:<br>    image: jaegertracing/all-in-one:latest<br>    restart: on-failure<br>    ports:<br>      - &quot;6831:6831/udp&quot;<br>      - &quot;6832:6832/udp&quot;<br>      - &quot;16686:16686&quot;<br>      - &quot;5775:5775/udp&quot;<br>      - &quot;5778:5778&quot;<br>      - &quot;14268:14268&quot;<br>      - &quot;14250:14250&quot;<br>      - &quot;9411:9411&quot;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>docker常用命令</title>
    <link href="/2022/04/20/docker-common-commands/"/>
    <url>/2022/04/20/docker-common-commands/</url>
    
    <content type="html"><![CDATA[<p>Docker是一个开源的应用容器引擎，可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的Linux机器上，是后端开发必备的基础技能之一。</p><span id="more"></span><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>镜像是Docker中最重要的概念，是运行容器的前提。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Bash">docker <span class="hljs-built_in">help</span> image<br><br>Usage:  docker image COMMAND<br><br>Manage images<br><br>Commands:<br>  build       Build an image from a Dockerfile<br>  <span class="hljs-built_in">history</span>     Show the <span class="hljs-built_in">history</span> of an image<br>  import      Import the contents from a tarball to create a filesystem image<br>  inspect     Display detailed information on one or more images<br>  load        Load an image from a tar archive or STDIN<br>  ls          List images<br>  prune       Remove unused images<br>  pull        Pull an image or a repository from a registry<br>  push        Push an image or a repository to a registry<br>  rm          Remove one or more images<br>  save        Save one or more images to a tar archive (streamed to STDOUT by default)<br>  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE<br><br>Run <span class="hljs-string">&#x27;docker image COMMAND --help&#x27;</span> <span class="hljs-keyword">for</span> more information on a <span class="hljs-built_in">command</span>.<br></code></pre></td></tr></table></figure><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">docker [image] pull NAME[:TAG]<br><span class="hljs-comment"># 拉取ubuntu镜像</span><br>docker pull ubuntu:18.04<br></code></pre></td></tr></table></figure><h3 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash">docker image ls<br><span class="hljs-comment"># 或者</span><br>docker images<br><br></code></pre></td></tr></table></figure><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash">docker image rm 镜像ID<br><span class="hljs-comment"># 删除所有镜像</span><br>docker rmi $(docker images -q)<br><br></code></pre></td></tr></table></figure><h3 id="导出镜像"><a href="#导出镜像" class="headerlink" title="导出镜像"></a>导出镜像</h3><p>导出镜像要通过<code>NAME:TAG</code>导出。通过Image ID导出会丢失<code>NAME:TAG</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">docker save -o xxx.tar NAME:TAG<br><span class="hljs-comment"># 拉取ubutnu:18.04镜像</span><br>docker save -o ubuntu.18.04.tar ubuntu:18.04<br></code></pre></td></tr></table></figure><h3 id="导入镜像"><a href="#导入镜像" class="headerlink" title="导入镜像"></a>导入镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">docker [image] load -i 镜像文件<br><span class="hljs-comment"># 导入ubuntu镜像</span><br>docker [image] load -i ubuntu.18.04.tar<br></code></pre></td></tr></table></figure><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>容器是镜像的一个运行实例。</p><h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 查看当前运行容器</span><br>docker container ls<br><span class="hljs-comment"># 或者</span><br>docker ps<br><span class="hljs-comment"># 查看全部容器（运行&amp;停止）</span><br>docker container ls -a<br><span class="hljs-comment"># 或者</span><br>docker ps -a<br><span class="hljs-comment"># 查看所有的容器ID</span><br>docker ps -aq<br><br></code></pre></td></tr></table></figure><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>这是很重要的docker命令之一，我们要熟练掌握。详细如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs Bash">docker <span class="hljs-built_in">help</span> run<br><br>Usage:  docker run [OPTIONS] IMAGE [COMMAND] [ARG...]<br><br>Run a <span class="hljs-built_in">command</span> <span class="hljs-keyword">in</span> a new container<br><br>Options:<br>      --add-host list                  Add a custom host-to-IP mapping (host:ip)<br>  -a, --attach list                    Attach to STDIN, STDOUT or STDERR<br>      --blkio-weight uint16            Block IO (relative weight), between 10 and 1000, or 0<br>                                       to <span class="hljs-built_in">disable</span> (default 0)<br>      --blkio-weight-device list       Block IO weight (relative device weight) (default [])<br>      --cap-add list                   Add Linux capabilities<br>      --cap-drop list                  Drop Linux capabilities<br>      --cgroup-parent string           Optional parent cgroup <span class="hljs-keyword">for</span> the container<br>      --cgroupns string                Cgroup namespace to use (host|private)<br>                                       <span class="hljs-string">&#x27;host&#x27;</span>:    Run the container <span class="hljs-keyword">in</span> the Docker host<span class="hljs-string">&#x27;s</span><br><span class="hljs-string">                                       cgroup namespace</span><br><span class="hljs-string">                                       &#x27;</span>private<span class="hljs-string">&#x27;: Run the container in its own private cgroup</span><br><span class="hljs-string">                                       namespace</span><br><span class="hljs-string">                                       &#x27;</span><span class="hljs-string">&#x27;:        Use the cgroup namespace as configured by</span><br><span class="hljs-string">                                       the</span><br><span class="hljs-string">                                                  default-cgroupns-mode option on the daemon</span><br><span class="hljs-string">                                       (default)</span><br><span class="hljs-string">      --cidfile string                 Write the container ID to the file</span><br><span class="hljs-string">      --cpu-period int                 Limit CPU CFS (Completely Fair Scheduler) period</span><br><span class="hljs-string">      --cpu-quota int                  Limit CPU CFS (Completely Fair Scheduler) quota</span><br><span class="hljs-string">      --cpu-rt-period int              Limit CPU real-time period in microseconds</span><br><span class="hljs-string">      --cpu-rt-runtime int             Limit CPU real-time runtime in microseconds</span><br><span class="hljs-string">  -c, --cpu-shares int                 CPU shares (relative weight)</span><br><span class="hljs-string">      --cpus decimal                   Number of CPUs</span><br><span class="hljs-string">      --cpuset-cpus string             CPUs in which to allow execution (0-3, 0,1)</span><br><span class="hljs-string">      --cpuset-mems string             MEMs in which to allow execution (0-3, 0,1)</span><br><span class="hljs-string">  -d, --detach                         Run container in background and print container ID</span><br><span class="hljs-string">      --detach-keys string             Override the key sequence for detaching a container</span><br><span class="hljs-string">      --device list                    Add a host device to the container</span><br><span class="hljs-string">      --device-cgroup-rule list        Add a rule to the cgroup allowed devices list</span><br><span class="hljs-string">      --device-read-bps list           Limit read rate (bytes per second) from a device</span><br><span class="hljs-string">                                       (default [])</span><br><span class="hljs-string">      --device-read-iops list          Limit read rate (IO per second) from a device (default [])</span><br><span class="hljs-string">      --device-write-bps list          Limit write rate (bytes per second) to a device</span><br><span class="hljs-string">                                       (default [])</span><br><span class="hljs-string">      --device-write-iops list         Limit write rate (IO per second) to a device (default [])</span><br><span class="hljs-string">      --disable-content-trust          Skip image verification (default true)</span><br><span class="hljs-string">      --dns list                       Set custom DNS servers</span><br><span class="hljs-string">      --dns-option list                Set DNS options</span><br><span class="hljs-string">      --dns-search list                Set custom DNS search domains</span><br><span class="hljs-string">      --domainname string              Container NIS domain name</span><br><span class="hljs-string">      --entrypoint string              Overwrite the default ENTRYPOINT of the image</span><br><span class="hljs-string">  -e, --env list                       Set environment variables</span><br><span class="hljs-string">      --env-file list                  Read in a file of environment variables</span><br><span class="hljs-string">      --expose list                    Expose a port or a range of ports</span><br><span class="hljs-string">      --gpus gpu-request               GPU devices to add to the container (&#x27;</span>all<span class="hljs-string">&#x27; to pass all</span><br><span class="hljs-string">                                       GPUs)</span><br><span class="hljs-string">      --group-add list                 Add additional groups to join</span><br><span class="hljs-string">      --health-cmd string              Command to run to check health</span><br><span class="hljs-string">      --health-interval duration       Time between running the check (ms|s|m|h) (default 0s)</span><br><span class="hljs-string">      --health-retries int             Consecutive failures needed to report unhealthy</span><br><span class="hljs-string">      --health-start-period duration   Start period for the container to initialize before</span><br><span class="hljs-string">                                       starting health-retries countdown (ms|s|m|h) (default 0s)</span><br><span class="hljs-string">      --health-timeout duration        Maximum time to allow one check to run (ms|s|m|h)</span><br><span class="hljs-string">                                       (default 0s)</span><br><span class="hljs-string">      --help                           Print usage</span><br><span class="hljs-string">  -h, --hostname string                Container host name</span><br><span class="hljs-string">      --init                           Run an init inside the container that forwards signals</span><br><span class="hljs-string">                                       and reaps processes</span><br><span class="hljs-string">  -i, --interactive                    Keep STDIN open even if not attached</span><br><span class="hljs-string">      --ip string                      IPv4 address (e.g., 172.30.100.104)</span><br><span class="hljs-string">      --ip6 string                     IPv6 address (e.g., 2001:db8::33)</span><br><span class="hljs-string">      --ipc string                     IPC mode to use</span><br><span class="hljs-string">      --isolation string               Container isolation technology</span><br><span class="hljs-string">      --kernel-memory bytes            Kernel memory limit</span><br><span class="hljs-string">  -l, --label list                     Set meta data on a container</span><br><span class="hljs-string">      --label-file list                Read in a line delimited file of labels</span><br><span class="hljs-string">      --link list                      Add link to another container</span><br><span class="hljs-string">      --link-local-ip list             Container IPv4/IPv6 link-local addresses</span><br><span class="hljs-string">      --log-driver string              Logging driver for the container</span><br><span class="hljs-string">      --log-opt list                   Log driver options</span><br><span class="hljs-string">      --mac-address string             Container MAC address (e.g., 92:d0:c6:0a:29:33)</span><br><span class="hljs-string">  -m, --memory bytes                   Memory limit</span><br><span class="hljs-string">      --memory-reservation bytes       Memory soft limit</span><br><span class="hljs-string">      --memory-swap bytes              Swap limit equal to memory plus swap: &#x27;</span>-1<span class="hljs-string">&#x27; to enable</span><br><span class="hljs-string">                                       unlimited swap</span><br><span class="hljs-string">      --memory-swappiness int          Tune container memory swappiness (0 to 100) (default -1)</span><br><span class="hljs-string">      --mount mount                    Attach a filesystem mount to the container</span><br><span class="hljs-string">      --name string                    Assign a name to the container</span><br><span class="hljs-string">      --network network                Connect a container to a network</span><br><span class="hljs-string">      --network-alias list             Add network-scoped alias for the container</span><br><span class="hljs-string">      --no-healthcheck                 Disable any container-specified HEALTHCHECK</span><br><span class="hljs-string">      --oom-kill-disable               Disable OOM Killer</span><br><span class="hljs-string">      --oom-score-adj int              Tune host&#x27;</span>s OOM preferences (-1000 to 1000)<br>      --pid string                     PID namespace to use<br>      --pids-limit int                 Tune container pids <span class="hljs-built_in">limit</span> (<span class="hljs-built_in">set</span> -1 <span class="hljs-keyword">for</span> unlimited)<br>      --platform string                Set platform <span class="hljs-keyword">if</span> server is multi-platform capable<br>      --privileged                     Give extended privileges to this container<br>  -p, --publish list                   Publish a container<span class="hljs-string">&#x27;s port(s) to the host</span><br><span class="hljs-string">  -P, --publish-all                    Publish all exposed ports to random ports</span><br><span class="hljs-string">      --pull string                    Pull image before running (&quot;always&quot;|&quot;missing&quot;|&quot;never&quot;)</span><br><span class="hljs-string">                                       (default &quot;missing&quot;)</span><br><span class="hljs-string">      --read-only                      Mount the container&#x27;</span>s root filesystem as <span class="hljs-built_in">read</span> only<br>      --restart string                 Restart policy to apply when a container exits<br>                                       (default <span class="hljs-string">&quot;no&quot;</span>)<br>      --rm                             Automatically remove the container when it exits<br>      --runtime string                 Runtime to use <span class="hljs-keyword">for</span> this container<br>      --security-opt list              Security Options<br>      --shm-size bytes                 Size of /dev/shm<br>      --sig-proxy                      Proxy received signals to the process (default <span class="hljs-literal">true</span>)<br>      --stop-signal string             Signal to stop a container (default <span class="hljs-string">&quot;SIGTERM&quot;</span>)<br>      --stop-timeout int               Timeout (<span class="hljs-keyword">in</span> seconds) to stop a container<br>      --storage-opt list               Storage driver options <span class="hljs-keyword">for</span> the container<br>      --sysctl map                     Sysctl options (default map[])<br>      --tmpfs list                     Mount a tmpfs directory<br>  -t, --tty                            Allocate a pseudo-TTY<br>      --<span class="hljs-built_in">ulimit</span> <span class="hljs-built_in">ulimit</span>                  Ulimit options (default [])<br>  -u, --user string                    Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;])<br>      --userns string                  User namespace to use<br>      --uts string                     UTS namespace to use<br>  -v, --volume list                    Bind mount a volume<br>      --volume-driver string           Optional volume driver <span class="hljs-keyword">for</span> the container<br>      --volumes-from list              Mount volumes from the specified container(s)<br>  -w, --workdir string                 Working directory inside the container<br></code></pre></td></tr></table></figure><p>这里有几个重要的命令行参数介绍：</p><ul><li>-d：—detach。可以脱离主进程，使容器在后台运行。</li><li>—rm：在容器退出后删除当前容器。</li><li>-p：–publish。将容器端口发布到宿主机端口上。</li><li>-P：–publish-all。将容器所有暴露的端口发布到宿主机随机端口上。</li><li>-e：—env。设置容器启动的环境变量。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">docker run --rm -d -e APP_ENV=online -p8000:8000 casbin/casdoor-all-in-one<br></code></pre></td></tr></table></figure><h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash">docker container stop 容器ID<br><span class="hljs-comment"># 停止所有的容器</span><br>docker stop $(docker ps -aq)<br><br></code></pre></td></tr></table></figure><h3 id="启动容器-1"><a href="#启动容器-1" class="headerlink" title="启动容器"></a>启动容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">docker container start 容器ID<br></code></pre></td></tr></table></figure><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-comment"># 删除某个容器</span><br>docker container rm 容器ID<br><span class="hljs-comment"># 删除所有停止的容器</span><br>docker container prune<br><span class="hljs-comment"># 删除所有的容器</span><br>docker rm $(docker ps -aq)<br><br></code></pre></td></tr></table></figure><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Bash">docker <span class="hljs-built_in">exec</span> -it 容器ID 命令<br><span class="hljs-comment"># docker ps</span><br>CONTAINER ID   IMAGE         COMMAND                  CREATED          STATUS          PORTS                      NAMES<br>9ff9c273c345   redis         <span class="hljs-string">&quot;docker-entrypoint.s…&quot;</span>   16 minutes ago   Up 16 minutes   0.0.0.0:6379-&gt;6379/tcp     redis_redis_1<br><span class="hljs-comment"># 进入redis容器</span><br>docker <span class="hljs-built_in">exec</span> -it 9ff9c273c345 bash<br><span class="hljs-comment"># 或者</span><br>docker run -it 镜像ID 命令<br><span class="hljs-comment"># 例如进入etcd容器</span><br>docker run -it bitnami/etcd bash<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何去设计服务指标？</title>
    <link href="/2022/03/05/metrics-desgin/"/>
    <url>/2022/03/05/metrics-desgin/</url>
    
    <content type="html"><![CDATA[<p>metrics直译是“度量”，是对系统指标可量化程度的测量。</p><span id="more"></span><h2 id="what-is-metrics"><a href="#what-is-metrics" class="headerlink" title="what is metrics?"></a>what is metrics?</h2><p>metrics是衡量系统情况的方法。也是系统监控的重要度量。</p><h3 id="why-use-metrics"><a href="#why-use-metrics" class="headerlink" title="why use metrics?"></a>why use metrics?</h3><p>google SRE 提出了应用监控的四个黄金指标。可以观测到应用的运行情况，做到风险监控，风险预警，故障排查等。</p><h4 id="latency（延迟）"><a href="#latency（延迟）" class="headerlink" title="latency（延迟）"></a>latency（延迟）</h4><p>服务处理某个请求需要的时间。这里区分成功请求和失败请求很重要。例如，某个由于数据库连接丢失或者其他后端问题造成的HTTP 500错误可能延迟很低。计算总体延迟低，如果将500回复的延迟也计算在内，可能会产生误导性的结果。但是，慢错误要比快错误更糟！因为，监控错误请求的延迟是很重要的。</p><h4 id="traffic（流量）"><a href="#traffic（流量）" class="headerlink" title="traffic（流量）"></a>traffic（流量）</h4><p>应用系统请求。该指标通常是每秒HTTP 请求数量。</p><h4 id="errors（错误）"><a href="#errors（错误）" class="headerlink" title="errors（错误）"></a>errors（错误）</h4><p>请求失败的速率。失败的方式大概有两种：一种是显式失败（例如HTTP 500），一种是隐式失败（例如HTTP 200回复中包含了错误内容）。</p><h4 id="saturation（饱和度）"><a href="#saturation（饱和度）" class="headerlink" title="saturation（饱和度）"></a>saturation（饱和度）</h4><p>服务容量有多“满”，通常是系统中目前最为受限的某种资源的某个具体指标的度量。很多系统在达到100%利用率之前性能会严重下降，增加一个利用率目标也是很重要的。</p><h2 id="how-to-use-metrics"><a href="#how-to-use-metrics" class="headerlink" title="how to use metrics?"></a>how to use metrics?</h2><p>prometheus提供了四种metrics类型，可以采集不同类型的指标数据。</p><h3 id="Counter（计数器）"><a href="#Counter（计数器）" class="headerlink" title="Counter（计数器）"></a>Counter（计数器）</h3><p>Counter类型的指标其工作方式和计数器一样，只增不减（除非系统发生重置）。</p><h4 id="when-to-use"><a href="#when-to-use" class="headerlink" title="when to use?"></a>when to use?</h4><ul><li>你想统计只增不减指标的时候</li><li>你想计算查询时间区间增长速率的时候</li></ul><h4 id="usecase"><a href="#usecase" class="headerlink" title="usecase"></a>usecase</h4><ul><li>请求总数</li><li>请求失败总数</li></ul><h3 id="Gauges（仪表盘）"><a href="#Gauges（仪表盘）" class="headerlink" title="Gauges（仪表盘）"></a>Gauges（仪表盘）</h3><p>Gauges与Counter不同，这类指标的样本数据可增可减，因此Gauge类型的指标侧重于反应系统的当前状态比如内存占用。</p><h4 id="when-to-use-1"><a href="#when-to-use-1" class="headerlink" title="when to use?"></a>when to use?</h4><ul><li>你想统计可增可减指标的时候</li><li>你不需要计算查询时间区间变化速率的时候</li></ul><h4 id="usecase-1"><a href="#usecase-1" class="headerlink" title="usecase"></a>usecase</h4><ul><li>队列数量</li><li>内存占用</li><li>当前进程内请求</li></ul><h3 id="Histograme（直方图）"><a href="#Histograme（直方图）" class="headerlink" title="Histograme（直方图）"></a>Histograme（直方图）</h3><p>Histogram主用用于统计和分析样本的分布情况。</p><p>在大多数情况下人们都倾向于使用某些量化指标的平均值，例如CPU的平均使用率、页面的平均响应时间。这种方式的问题很明显，以系统API调用的平均响应时间为例：如果大多数API请求都维持在100ms的响应时间范围内，而个别请求的响应时间需要5s，那么就会导致某些WEB页面的响应时间落到中位数的情况，而这种现象被称为长尾问题。</p><p>为了区分是平均的慢还是长尾的慢，最简单的方式就是按照请求延迟的范围进行分组。例如，统计延迟在0<del>10ms之间的请求数有多少而10</del>20ms之间的请求数又有多少。通过这种方式可以快速分析系统慢的原因。因此通过Histogram指标，我们可以快速了解监控样本的分布情况。</p><h4 id="when-to-use-2"><a href="#when-to-use-2" class="headerlink" title="when to use?"></a>when to use?</h4><ul><li>你想统计指标的平均值或者百分位的时候</li></ul><h4 id="usecase-2"><a href="#usecase-2" class="headerlink" title="usecase"></a>usecase</h4><ul><li>请求延迟时间</li><li>响应body大小</li></ul><h3 id="Summary（摘要）"><a href="#Summary（摘要）" class="headerlink" title="Summary（摘要）"></a>Summary（摘要）</h3><p>Summary指标和Histogram指标类似，区别是Histogram指标的计算是在prometheus server计算的，所以支持分布式应用的聚合计算，而Summary指标是在prometheus client端也就是在application server端计算的百分位，因此Summary指标不支持分布式应用的指标统计。</p><p>如果有统计指标的平均值或者百分位需求的时候，请使用Histograme而不是Summary！</p><h2 id="metrics-design"><a href="#metrics-design" class="headerlink" title="metrics design"></a>metrics design</h2><h3 id="metrics命名规范"><a href="#metrics命名规范" class="headerlink" title="metrics命名规范"></a>metrics命名规范</h3><ul><li>必须以[a-zA-Z]字母开头，可使用”_”拼接字符。符合下划线命名规则。切勿使用驼峰式命名。</li><li>Counter指标类型必须以total结尾。比如 server_requests_total。</li><li>必须显式的带上指标单位。比如 server_requests_lantency_seconds、server_response_body_bytes。</li></ul><h3 id="label命名规范"><a href="#label命名规范" class="headerlink" title="label命名规范"></a>label命名规范</h3><ul><li>必须以[a-zA-Z]字母开头，可使用”_”拼接字符。符合下划线命名规则。切勿使用驼峰式命名。</li><li>label是metrics的特征属性。切勿将label name设计到metrics name中。</li></ul><h3 id="业务级指标"><a href="#业务级指标" class="headerlink" title="业务级指标"></a>业务级指标</h3><ul><li>指标名称必须要以 app_name 为前缀。并且需要符合上面metrics的命名规范。也就是需要将app_name中的”[.-]”替换为”_”。</li></ul><h3 id="应用系统指标"><a href="#应用系统指标" class="headerlink" title="应用系统指标"></a>应用系统指标</h3><p>prometheus指标采集的时候可以自动加上app_name label。所以我们的应用系统指标不需要额外采集了。</p><h4 id="server-requests-success-total"><a href="#server-requests-success-total" class="headerlink" title="server_requests_success_total"></a>server_requests_success_total</h4><p>服务端请求总数。Counter指标类型</p><h4 id="label"><a href="#label" class="headerlink" title="label"></a>label</h4><ul><li><strong>operation</strong>。请求方法。对应GRPC method。例如/app.v1.AppService/GetApp</li></ul><h4 id="server-requests-error-total"><a href="#server-requests-error-total" class="headerlink" title="server_requests_error_total"></a>server_requests_error_total</h4><p>服务请求错误总数。</p><h4 id="label-1"><a href="#label-1" class="headerlink" title="label"></a>label</h4><ul><li><strong>operation</strong>。请求方法。对应GRPC method。例如/app.v1.AppService/GetApp</li></ul><h4 id="server-requests-success-latency-seconds"><a href="#server-requests-success-latency-seconds" class="headerlink" title="server_requests_success_latency_seconds"></a>server_requests_success_latency_seconds</h4><p>服务端成功请求延迟。Histogram指标类型</p><h4 id="label-2"><a href="#label-2" class="headerlink" title="label"></a>label</h4><ul><li><strong>operation</strong>。请求方法。对应GRPC method。例如/app.v1.AppService/GetApp</li></ul><h4 id="server-requests-error-latency-seconds"><a href="#server-requests-error-latency-seconds" class="headerlink" title="server_requests_error_latency_seconds"></a>server_requests_error_latency_seconds</h4><p>服务端错误请求延迟。Histogram指标类型</p><h4 id="label-3"><a href="#label-3" class="headerlink" title="label"></a>label</h4><ul><li><strong>operation</strong>。请求方法。对应GRPC method。例如/app.v1.AppService/GetApp</li></ul><h4 id="client-requests-success-total"><a href="#client-requests-success-total" class="headerlink" title="client_requests_success_total"></a>client_requests_success_total</h4><p>客户端请求成功总数。Counter指标类型</p><h4 id="label-4"><a href="#label-4" class="headerlink" title="label"></a>label</h4><ul><li><strong>operation</strong>。请求方法。对应GRPC method。例如/app.v1.AppService/GetApp</li></ul><h4 id="client-requests-error-total"><a href="#client-requests-error-total" class="headerlink" title="client_requests_error_total"></a>client_requests_error_total</h4><p>客户端请求失败总数。Counter指标类型</p><h4 id="label-5"><a href="#label-5" class="headerlink" title="label"></a>label</h4><ul><li><strong>operation</strong>。请求方法。对应GRPC method。例如/app.v1.AppService/GetApp</li></ul><h4 id="client-requests-success-latency-seconds"><a href="#client-requests-success-latency-seconds" class="headerlink" title="client_requests_success_latency_seconds"></a>client_requests_success_latency_seconds</h4><p>服务端成功请求延迟。Histogram指标类型</p><h4 id="label-6"><a href="#label-6" class="headerlink" title="label"></a>label</h4><ul><li><strong>operation</strong>。请求方法。对应GRPC method。例如/app.v1.AppService/GetApp</li></ul><h4 id="client-requests-error-latency-seconds"><a href="#client-requests-error-latency-seconds" class="headerlink" title="client_requests_error_latency_seconds"></a>client_requests_error_latency_seconds</h4><p>服务端错误请求延迟。Histogram指标类型</p><h4 id="label-7"><a href="#label-7" class="headerlink" title="label"></a>label</h4><ul><li><strong>operation</strong>。请求方法。对应GRPC method。例如/app.v1.AppService/GetApp</li></ul><h4 id="db-requests-success-total"><a href="#db-requests-success-total" class="headerlink" title="db_requests_success_total"></a>db_requests_success_total</h4><p>数据库请求成功总数。Counter指标类型</p><h4 id="label-8"><a href="#label-8" class="headerlink" title="label"></a>label</h4><ul><li><strong>operation</strong>。请求方法。对应GRPC method。例如/app.v1.AppService/GetApp</li><li><strong>s</strong>ystem。数据库类型。例如mysql/es/mongo</li></ul><h4 id="db-requests-error-total"><a href="#db-requests-error-total" class="headerlink" title="db_requests_error_total"></a>db_requests_error_total</h4><p>数据库请求失败总数。Counter指标类型</p><h4 id="label-9"><a href="#label-9" class="headerlink" title="label"></a>label</h4><ul><li><strong>operation</strong>。请求方法。对应GRPC method。例如/app.v1.AppService/GetApp</li><li><strong>kind</strong>。数据库类型。例如mysql/es/mongo</li></ul><h4 id="db-requests-success-latency-seconds"><a href="#db-requests-success-latency-seconds" class="headerlink" title="db_requests_success_latency_seconds"></a>db_requests_success_latency_seconds</h4><p>数据库成功请求延迟。Histogram指标类型</p><h4 id="label-10"><a href="#label-10" class="headerlink" title="label"></a>label</h4><ul><li><strong>operation</strong>。请求方法。对应GRPC method。例如/app.v1.AppService/GetApp</li><li><strong>system</strong>。数据库类型。例如mysql/es/mongo</li></ul><h4 id="db-requests-error-latency-seconds"><a href="#db-requests-error-latency-seconds" class="headerlink" title="db_requests_error_latency_seconds"></a>db_requests_error_latency_seconds</h4><p>数据库错误请求延迟。Histogram指标类型</p><h4 id="label-11"><a href="#label-11" class="headerlink" title="label"></a>label</h4><ul><li><strong>operation</strong>。请求方法。对应GRPC method。例如/app.v1.AppService/GetApp</li><li><strong>system</strong>。数据库类型。例如mysql/es/mongo</li></ul><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://prometheus.io/docs/practices/naming/">https://prometheus.io/docs/practices/naming/</a></p><p><a href="https://prometheus.io/docs/concepts/data_model/">https://prometheus.io/docs/concepts/data_model/</a></p><p><a href="https://docs.datadoghq.com/developers/guide/what-best-practices-are-recommended-for-naming-metrics-and-tags/">https://docs.datadoghq.com/developers/guide/what-best-practices-are-recommended-for-naming-metrics-and-tags/</a></p><p><a href="https://sre.google/sre-book/monitoring-distributed-systems/">https://sre.google/sre-book/monitoring-distributed-systems/</a></p><p><a href="https://prometheus.io/docs/concepts/metric_types/">https://prometheus.io/docs/concepts/metric_types/</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>工程目录设计</title>
    <link href="/2022/02/19/%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/02/19/%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>借鉴<a href="https://github.com/go-kratos/kratos">go-kraotos</a>，以及DDD领域模型的设计思想，设计出的通用的面向GO WEB开发的工程目录。</p><span id="more"></span><h2 id="一级目录"><a href="#一级目录" class="headerlink" title="一级目录"></a>一级目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Bash">├── api<br>├── cmd<br>├── configs<br>├── deployments<br>├── internal<br>├── pkg<br>├── web<br>├── go.mod<br>├── go.sum<br>├── README.md<br></code></pre></td></tr></table></figure><h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><ul><li>定义<code>http/grpc</code> 服务，其中包括<code>http server</code>、<code>http client</code>、<code>grpc server</code>、<code>grpc client</code></li><li>定义数据载体DTO（<code>Data Transfer Object</code>），以及数据载体（DTO）的验证。</li><li>定义<code>api errors</code>。</li><li>定义接口文档。</li></ul><p>具体的目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Bash">├── api<br>│   ├── bulk<br>│   │   └── v1<br>│   │       ├── esbulk.pb.go<br>│   │       ├── esbulk.proto<br>│   │       ├── esbulk.swagger.json<br>│   │       ├── esbulk_grpc.pb.go<br>│   │       └── esbulk_http.pb.go<br>│   ├── errors.pb.go<br>│   ├── errors.proto<br>│   └── search<br>│       └── v1<br>│           ├── essearch.pb.go<br>│           ├── essearch.proto<br>│           ├── essearch.swagger.json<br>│           ├── essearch_grpc.pb.go<br>│           └── essearch_http.pb.go<br></code></pre></td></tr></table></figure><h3 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h3><ul><li>app的入口，服务启动的地方，也就是<code>main.go</code>定义的地方。</li><li>做服务初始化。对象的依赖注入（<code>google wire</code>）。</li></ul><p>具体的结构目录如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">├── cmd<br>│   └── es-api<br>│       ├── main.go<br>│       ├── wire.go<br>│       └── wire_gen.go<br></code></pre></td></tr></table></figure><h3 id="configs"><a href="#configs" class="headerlink" title="configs"></a>configs</h3><p>放置项目的配置文件。</p><p>具体的结构目录如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">├── configs<br>│   └── config.yaml<br></code></pre></td></tr></table></figure><h3 id="deployments"><a href="#deployments" class="headerlink" title="deployments"></a>deployments</h3><ul><li>定义项目build deploy部署文件。比如<code>dockerfile</code>、<code>kubernetes.yaml</code></li></ul><p>具体的结构目录如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">├── deployments<br>│   ├── Dockefile<br>│   ├── kubernetes.yaml<br></code></pre></td></tr></table></figure><h3 id="internal"><a href="#internal" class="headerlink" title="internal"></a>internal</h3><ul><li>私有目录，对外部包不可见，编写业务代码的地方。</li></ul><p>internal层借鉴了标准mvc的目录结构，借鉴了DDD领域驱动设计的思想，拆分为以下几个层级。</p><p>具体的结构目录如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Bash">├── internal<br>│   ├── controller<br>│   ├── data<br>│   ├── domain<br>│   ├── facade<br>│   ├── server<br>│   ├── service<br></code></pre></td></tr></table></figure><h4 id="domain"><a href="#domain" class="headerlink" title="domain"></a>domain</h4><p>具体的结构目录如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">├── domain<br>│   ├── user.go<br></code></pre></td></tr></table></figure><ul><li>抽象领域驱动模型对象DO（<code>domain object</code>），DO是业务实体的抽象。</li><li>实现DO对象的业务方法。</li></ul><h4 id="server"><a href="#server" class="headerlink" title="server"></a>server</h4><ul><li>负责<code>grpc server</code>、<code>http server</code>实例的初始化。</li><li>将controller实现注入<code>grpc server</code>、<code>http server</code>。</li></ul><h4 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h4><ul><li>实现<code>api</code>层定义的服务接口。</li><li>消息载体<code>DTO</code>到领域模型<code>DO</code>的转化，以及<code>DO</code>到<code>DTO</code>的转化。</li><li>编排<code>service</code>层。在这一层，我们可以清楚的看到业务逻辑，但是不应该看到具体业务的实现。</li></ul><p>具体的结构目录如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">├── controller<br>│   ├── controller.go<br>│   ├── user.go<br></code></pre></td></tr></table></figure><h4 id="service"><a href="#service" class="headerlink" title="service"></a>service</h4><ul><li>负责具体业务的实现，完整业务的闭环，不应该存在任何依赖。</li><li>定义 <code>repo</code>、<code>业务错误</code>、<code>第三方api</code>的地方。</li><li>负责 <code>业务错误</code> 到 <code>apierrors</code> 的转换。</li></ul><p>层级如下：</p><ul><li>service.go 做 wire providerSet的定义</li><li>user.go 是具体的业务实现</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">├── service<br>│   ├── service.go<br>│   └── user.go<br></code></pre></td></tr></table></figure><p>如果要业务形态变得越来越复杂，也可以讲service目录按照业务分包。层级如下：</p><ul><li>interface.go 业务接口的定义，比如<code>repo</code>、<code>外部api</code>。</li><li>service.go 负责service的构造，并且负责业务的实现。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Bash">service<br>    ├── blog<br>    │   ├── interface.go<br>    │   └── service.go<br>    ├── service.go<br>    └── user<br>        ├── interface.go<br>        └── service.go<br></code></pre></td></tr></table></figure><h4 id="facade"><a href="#facade" class="headerlink" title="facade"></a>facade</h4><ul><li>防腐层设计，定义外部接口API的地方（<code>http/grpc</code>），也为了防止外部API的改动而对项目造成破坏。</li></ul><p>具体的结构目录如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">├── facade<br>│   └── wxrobot<br>│       ├── api<br>│       │   └── robot_api.go<br>│       ├── client.go<br></code></pre></td></tr></table></figure><h4 id="data"><a href="#data" class="headerlink" title="data"></a>data</h4><ul><li>管理存储对象的生命周期。</li><li>数据出口。实现<code>service</code>层定义的<code>DataRepo</code>。</li><li>和数据存储打交道，比如（<code>redis</code>、<code>mysql</code>、<code>localcache</code>等等）。</li><li>管理<code>model migration</code>。</li><li>管理<code>model</code>目录。定义持久化对象PO（<code>Persistent Object</code>），仅和存储打交道，对<code>data</code>层级外不可见。</li><li>DO模型到PO模型的转化，以及PO模型到DO模型的转化。</li></ul><p>具体的结构目录如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Bash">├── data<br>│   ├── data.go<br>│   ├── model<br>│   │   ├── model.go<br>│   │   └── user.go<br>│   └── user.go<br></code></pre></td></tr></table></figure><h3 id="pkg"><a href="#pkg" class="headerlink" title="pkg"></a>pkg</h3><ul><li>定义公共代码。包对外部可见。</li></ul><h3 id="web"><a href="#web" class="headerlink" title="web"></a>web</h3><ul><li>前端web代码</li></ul><h3 id="工程目录模型流转图"><a href="#工程目录模型流转图" class="headerlink" title="工程目录模型流转图"></a>工程目录模型流转图</h3><p><img src="/images/%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95%E8%AE%BE%E8%AE%A1%E6%B5%81%E8%BD%AC%E5%9B%BE.jpg" alt="工程目录设计流转图"></p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><ul><li><a href="https://github.com/go-kratos/beer-shop">beer-shop</a></li><li><a href="https://github.com/lyouthzzz/go-web-layout">go-web-layout</a></li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://github.com/go-kratos/kratos-layout">kratos-layout</a></li><li><a href="https://github.com/go-kratos/beer-shop">beer-shop</a></li><li><a href="https://github.com/bxcodec/go-clean-arch">go-clean-arch</a></li><li><a href="https://github.com/eminetto/clean-architecture-go">clean-architecture-go</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
