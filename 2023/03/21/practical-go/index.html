

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="Dave Cheney qcon-china分享的一篇非常好的Go编程指导。
">
  <meta name="author" content="youn">
  <meta name="keywords" content="">
  
  <title>实用Go，编写可维护的Go代码的真实建议（译自Dave Cheney） - youn</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"younman.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="youn" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>写作是一种深度思考</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="实用Go，编写可维护的Go代码的真实建议（译自Dave Cheney）">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-03-21 08:03" pubdate>
        2023年3月21日 早上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      21.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      256
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">实用Go，编写可维护的Go代码的真实建议（译自Dave Cheney）</h1>
            
            <div class="markdown-body">
              <p>Dave Cheney qcon-china分享的一篇非常好的Go编程指导。</p>
<br>

<span id="more"></span>

<blockquote>
<p>🚦翻译自<strong>Dave Cheney</strong> <a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html" title="https://dave.cheney.net/practical-go/presentations/qcon-china.html"><strong>https://dave.cheney.net/practical-go/presentations/qcon-china.html</strong></a></p>
</blockquote>
<br>

<h2 id="1-指导原则"><a href="#1-指导原则" class="headerlink" title="1. 指导原则"></a>1. 指导原则</h2><p>我可能是Go最早的使用者之一，但认为我的资历会让我的观点更有分量是错误的。相反，我今天要提出的建议是基于我认为Go本身的指导原则。  </p>
<ol>
<li> 简洁性</li>
<li> 可读性</li>
<li> 生产力</li>
</ol>
<br>

<blockquote>
<p><strong>NOTE：你会注意到我并没有说性能或并发性。有一些语言比Go更快一些，但它们肯定不像Go那样简单易懂。有一些语言把并发性作为最高目标，但它们既不容易阅读，也不具备高效性。</strong> </p>
</blockquote>
<br>

<p>性能和并发性是重要的属性，但并不像简单易懂、易读和高效率那样重要。</p>
<br>

<h3 id="1-1-简洁的"><a href="#1-1-简洁的" class="headerlink" title="1.1 简洁的"></a>1.1 简洁的</h3><blockquote>
<p><strong>“简洁是可靠性的先决条件。— Edsger W. Dijkstra”</strong></p>
</blockquote>
<br>

<p>我们为什么应该追求简洁性？Go程序为什么需要简单？</p>
<br>

<p>我们都曾经遇到过这样的情况：你说“我无法理解这段代码”，对吗？我们都曾经在程序中工作过，你害怕进行更改，因为你担心它会破坏程序的另一部分，你不理解并且不知道如何修复。这就是复杂性。</p>
<br>

<blockquote>
<p><strong>“构建软件设计有两种方式：一种方式是使其变得非常简单，以至于明显没有缺陷；另一种方式是使其变得非常复杂，以至于没有明显的缺陷。第一种方法要困难得多。— C. A. R. Hoare”</strong></p>
</blockquote>
<br>

<p>复杂性会使得可靠的软件变得不可靠。复杂性是导致软件项目失败的原因。因此，简单性是Go语言的最高目标。无论我们编写什么样的程序，我们都应该认为它们是简洁的。</p>
<br>

<h3 id="1-2可读性"><a href="#1-2可读性" class="headerlink" title="1.2可读性"></a>1.2可读性</h3><blockquote>
<p><strong>“可读性对于可维护至关重要。— Mark ReinholdJVM language summit 2018”</strong></p>
</blockquote>
<br>

<p>可读性很重要，因为所有软件，不仅仅是 Go 程序，都是由人类编写的，旨在供其他人类阅读。软件也被机器使用这一事实是次要的。</p>
<br>

<p>代码被阅读的次数比编写的次数多得多。一段代码在其生命周期内，可能会被阅读数百次，甚至可能数千次。</p>
<br>

<blockquote>
<p><strong>“对于程序员来说，最重要的技能是有效地传达思想的能力。— Gastón Jorquera”</strong></p>
</blockquote>
<br>

<p>可读性对于理解程序的运作方式非常关键。如果您无法理解程序正在做什么，又怎么能希望对其进行维护呢？如果软件无法进行维护，那么它将会被重新编写。</p>
<br>

<p>如果您是为自己编写程序，也许它只需要运行一次，或者只有您自己会看到它，那么就做任何适合自己的事情吧。但是，如果这是一款多人贡献或将被人们长时间使用的软件，可能在需求、功能或运行环境上发生变化，那么您的目标必须是使程序易于维护。</p>
<br>

<p>编写易于维护的代码的第一步是确保代码易读。</p>
<br>

<h3 id="1-3-生产力"><a href="#1-3-生产力" class="headerlink" title="1.3 生产力"></a>1.3 生产力</h3><blockquote>
<p><strong>“设计是一门艺术，其目的在于安排代码使其今天可以正常运作，并且在未来也是可以轻松进行更改的。— Sandi Metz”</strong></p>
</blockquote>
<br>

<p>我想强调的最后一个基本原则是生产力。开发者的生产力是一个广泛的话题，但归根结底，它可以归纳为这个问题：你花多少时间进行有用的工作，相对于等待你的工具或在陌生的代码库中无助地迷失方向。Go程序员应该感到他们可以用Go完成很多工作。</p>
<br>

<p>这个笑话是这样说的，Go是在等待C++程序编译时设计出来的。快速编译是Go的一个关键特性，也是吸引新开发人员的一个关键招聘工具。虽然编译速度仍然是一个不断争夺的战场，但可以公正地说，在其他语言中需要几分钟的编译，在Go中只需要几秒钟。这有助于让Go开发人员感到像使用动态语言的同行一样富有生产力，而不会遇到这些语言固有的可靠性问题。</p>
<br>

<p>对于开发人员的生产力问题来说，更基本的是，Go程序员意识到代码是写来阅读的，因此把阅读代码的行为放在编写代码的行为之上。Go甚至通过工具和自定义来强制要求所有的代码都采用特定的格式。这消除了学习项目特定方言的摩擦，并有助于发现错误，因为它们看起来就不正确。</p>
<br>

<p>Go程序员不会花费数天来调试晦涩难懂的编译错误。他们不会浪费时间用复杂的构建脚本或将代码部署到生产环境中。最重要的是，他们不会浪费时间来理解他们的同事所写的代码。</p>
<br>

<p>生产力是Go团队所说的语言必须具备可扩展性的意思。</p>
<br>

<h2 id="2-标识符"><a href="#2-标识符" class="headerlink" title="2.标识符"></a>2.标识符</h2><p>我们要讨论的第一个主题是标识符。标识符是一个用于表示名称的术语，可以是变量的名称、函数的名称、方法的名称、类型的名称、包的名称等等。</p>
<br>

<blockquote>
<p><strong>“糟糕的命名是糟糕的设计的症状。— Dave Cheney”</strong></p>
</blockquote>
<br>

<p>鉴于 Go 语言的语法限制，我们在程序中选择的命名方式对代码的可读性影响巨大。可读性是优秀代码的重要品质，因此选择良好的命名方式对于 Go 代码的可读性至关重要。</p>
<br>

<h3 id="2-1-选择易于理解而非简短的标识符"><a href="#2-1-选择易于理解而非简短的标识符" class="headerlink" title="2.1 选择易于理解而非简短的标识符"></a>2.1 选择易于理解而非简短的标识符</h3><blockquote>
<p><strong>“易于理解的代码很重要。你可以用一行代码完成的事情，应该用三行代码完成。— Ukiah Smith”</strong></p>
</blockquote>
<br>

<p>Go 不是一门优化聪明的一行代码的语言。Go 不是一门优化程序中最少行数的语言。我们并不优化程序在磁盘上的源代码大小，也不优化在编辑器中输入程序所需的时间。</p>
<br>

<blockquote>
<p><strong>“良好的命名就像一个好笑话。如果你需要解释它，那它就不好笑了。— Dave Cheney”</strong></p>
</blockquote>
<br>

<p>实现这种清晰度的关键是我们在 Go 程序中选择的标识符名称。让我们谈谈一个好名称的特质：</p>
<br>

<ul>
<li>  一个好的名称要简洁。一个好的名称不必是最短的，但一个好的名称不应浪费空间在无关紧要的事物上。好的名称具有高信号噪声比。</li>
<li>  一个好的名称应该是描述性的。一个好的名称应该描述一个变量或常量的应用，而不是它们的内容。一个好的名称应该描述一个函数的结果或方法的行为，而不是它们的实现。一个好的名称应该描述一个包的目的，而不是它的内容。一个名称描述它所标识的事物得越准确，这个名称就越好。</li>
<li>  一个好的名称应该是可预测的。你应该能够从它的名称中单独推断出一个符号将如何使用。这是选择描述性名称的一个函数，但也与遵循传统有关。这就是 Go 程序员谈论习惯用法时所说的内容。</li>
</ul>
<br>

<p>接着，让我们来深入探讨上面的每个特质。</p>
<br>

<h3 id="2-2-标识符长度"><a href="#2-2-标识符长度" class="headerlink" title="2.2 标识符长度"></a>2.2 标识符长度</h3><br>

<p>有时人们会批评Go语言风格，因为它推荐使用短变量名。正如<strong>Rob Pike</strong>所说：“Go程序员想要正确长度的标识符”。</p>
<br>

<p><strong>Andrew Gerrand</strong>建议通过使用更长的标识符来向读者指示更重要的事物。</p>
<br>

<blockquote>
<p><strong>“名称声明和使用之间的距离越大，名称就应该越长。— Andrew Gerrand”</strong></p>
</blockquote>
<br>

<p>由此我们可以得出一些指导原则：</p>
<br>

<ul>
<li>  当变量声明和最后一次使用之间的距离较短时，短变量名效果很好。</li>
<li>  长变量名需要证明它们自己的存在。它们越长，就需要提供越多的价值。与其在页面上所占的空间相比，冗长的官僚式名称传达的信息很少。</li>
<li>  不要在变量名中包含类型名称。</li>
<li>  常量应该描述它们所包含的值，而不是该值的使用方式。</li>
<li>  循环和分支语句中应该优先使用单个字母的变量名，函数和包级别的声明应该使用多个单词的变量名，参数和返回值应该使用单个单词。</li>
<li>  方法、接口和包应该使用单个单词。</li>
<li>  包的名称是调用方用来引用它的一部分名称，因此应该充分利用它。</li>
</ul>
<br>

<p>让我们来看一个示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>  Name <span class="hljs-keyword">string</span><br>  Age  <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-comment">// AverageAge returns the average age of people.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AverageAge</span><span class="hljs-params">(people []Person)</span> <span class="hljs-title">int</span></span> &#123;<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(people) == <span class="hljs-number">0</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>  &#125;<br><br>  <span class="hljs-keyword">var</span> count, sum <span class="hljs-keyword">int</span><br>  <span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> people &#123;<br>    sum += p.Age<br>    count += <span class="hljs-number">1</span><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> sum / count<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，范围变量p在第13行声明，并且只在下一行引用了一次。p的寿命在页面上和函数执行期间都非常短。对于对p对程序产生的影响感兴趣的读者，只需阅读两行。</p>
<br>

<p>相比之下，people在函数参数中声明，并且生存了七行。对于sum和count也是如此，因此它们证明了它们更长的名称的合理性。读者必须扫描更多的行才能找到它们，因此它们被赋予了更具有区分性的名称。</p>
<br>

<p>我本可以选择s表示sum，c（或可能是n）表示count，但这将使程序中的所有变量重要性相同。我本可以选择p而不是people，但这将导致如何称呼for … range迭代变量的问题。单数person作为循环迭代变量看起来很奇怪，因为它的寿命很短，但名称比它派生的值的切片长。</p>
<br>

<blockquote>
<p><strong>TIP：使用空行来分隔函数的流程，就像使用段落来分隔文档的流程一样。在AverageAge函数中，我们有三个按顺序发生的操作。第一个是前提条件，检查如果people为空，则不会除以零；第二个是求和和计数的累加，最后一个是计算平均值。</strong></p>
</blockquote>
<br>

<h4 id="2-2-1-上下文是关键"><a href="#2-2-1-上下文是关键" class="headerlink" title="2.2.1 上下文是关键"></a>2.2.1 上下文是关键</h4><br>

<p>大多数有关命名的建议是有上下文环境的。我喜欢说这是一个原则，而不是一个规则。</p>
<br>

<p>下面的两个标识符区别是，一个是<code>i</code>一个是<code>index</code>。我们很难说一个就比另外一个好。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> index := <span class="hljs-number">0</span>; index &lt; <span class="hljs-built_in">len</span>(s); index++ &#123;<br>  <span class="hljs-comment">//</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>比下面更易读，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>  <span class="hljs-comment">//</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我认为不是这样的，因为<code>i</code>的范围（以及索引）很可能仅限于<code>for</code>循环的主体部分，后者的额外冗长对程序的理解几乎没有帮助。</p>
<br>

<p>但是，下面的两个函数哪个可读性更高呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *SNMP)</span> <span class="hljs-title">Fetch</span><span class="hljs-params">(oid []<span class="hljs-keyword">int</span>, index <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *SNMP)</span> <span class="hljs-title">Fetch</span><span class="hljs-params">(o []<span class="hljs-keyword">int</span>, i <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span><br></code></pre></td></tr></table></figure>

<p>在这个例子中，oid是SNMP Object ID的缩写，因此将其缩短为o意味着程序员必须从文档中常见的表示法转换为代码中更短的表示法。同样，将index缩短为i也会隐藏i代表的含义，因为在SNMP消息中，每个OID的子值被称为索引。</p>
<br>

<blockquote>
<p><strong>TIP：不要在同一个声明中混用长形式参数和短形式参数。</strong></p>
</blockquote>
<br>

<h3 id="2-3-不要为变量命名其类型"><a href="#2-3-不要为变量命名其类型" class="headerlink" title="2.3 不要为变量命名其类型"></a>2.3 不要为变量命名其类型</h3><br>

<p>出于同样的原因，你不应该为变量命名其类型，就像你不会给你的宠物起名叫“狗”和“猫”一样。你也不应该在变量名中包含其类型名称，出于同样的原因。</p>
<br>

<p>变量的名称应该描述其内容，而不是内容的类型。考虑以下例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> usersMap <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*User<br></code></pre></td></tr></table></figure>

<p>这段话的意思是什么？ 我们可以看到这是<code>map</code>类型，与<code>*User</code>对象有关，这可能是好的。但是，<code>usersMap</code>是一个<code>map</code>，而Go是一种静态类型的语言，不会让我们意外地在需要标量变量的地方使用它，因此<code>Map</code>后缀是多余的。</p>
<br>

<p>现在，考虑一下如果我们声明其他变量会发生什么：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>  companiesMap <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*Company<br>  productsMap  <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*Products<br>)<br></code></pre></td></tr></table></figure>

<br>

<p>现在，我们的范围内有三个map类型的变量：<code>usersMap</code>、<code>companiesMap</code>和<code>productsMap</code>，它们都将字符串映射到不同的类型。我们知道它们都是<code>map</code>，而且它们的<code>map</code>声明防止我们在一个位置使用另一个——如果我们试图在期望一个<code>map[string]*User</code>的代码中使用<code>companiesMap</code>，编译器将抛出一个错误。在这种情况下，很明显<code>Map</code>后缀并没有提高代码的清晰度。</p>
<br>

<p><strong>我的建议是避免使用与变量类型类似的任何后缀。</strong></p>
<br>

<blockquote>
<p><strong>TIP：如果”user”这个词不够描述性，那么”usersMap”也不会更好。</strong></p>
</blockquote>
<br>

<p>这个建议同样适用于函数参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Config <span class="hljs-keyword">struct</span> &#123;<br>  <span class="hljs-comment">//</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WriteConfig</span><span class="hljs-params">(w io.Writer, config *Config)</span></span><br></code></pre></td></tr></table></figure>

<br>

<p>将 <code>*Config</code> 参数命名为 <code>config</code> 是多余的，我们知道它是 <code>*Config</code>。</p>
<br>

<p>在这种情况下，可以考虑使用 <code>conf</code>，或者如果变量的生命周期足够短，则可以使用<code>c</code>。</p>
<br>

<p>如果在任何时候作用域中存在多个<code>*Config</code>，则称它们为 <code>conf1</code> 和 <code>conf2</code> 不如称它们为 <code>original</code> 和 <code>updated</code> 描述性强，因为后者不太可能被误认为是彼此。</p>
<br>

<p>不要让包名抢走好的变量名。 导入的标识符的名称包括其包名。例如，上下文包中的上下文类型将被称为context.Context。这使得在您的包中使用context作为变量或类型变得不可能。</p>
<br>

<p><code>func WriteLog(context context.Context, message string) </code>无法编译。</p>
<br>

<p>这就是为什么传统上用于本地声明<code>context.Context</code>类型的变量名是<code>ctx</code>的原因，例如：</p>
<p><code>func WriteLog(ctx context.Context, message string)</code></p>
<br>

<h3 id="2-4使用一致的命名风格"><a href="#2-4使用一致的命名风格" class="headerlink" title="2.4使用一致的命名风格"></a>2.4使用一致的命名风格</h3><br>

<p>一个好的名称的另一个特性是可预测性。读者第一次遇到名称时应该能够理解其用途。当他们遇到常见的名称时，他们应该能够假设它自上次看到它以来没有改变过含义。</p>
<br>

<p>例如，如果您的代码需要传递一个数据库句柄，确保每次参数出现时它都有相同的名称。而不是像 <code>d *sql.DB</code>、<code>dbase *sql.DB</code>、<code>DB *sql.DB</code> 和 <code>database *sql.DB</code> 这样的组合，而是统一采用像这样的名称：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">db *sql.DB<br></code></pre></td></tr></table></figure>

<p>这样做有助于增加熟悉感；如果您看到一个 db，就知道它是一个 <code>*sql.DB</code>，并且它可能是在本地声明的，也可能是由调用者提供的。</p>
<br>

<p>类似的建议也适用于方法接收器；在该类型的每个方法中使用相同的接收器名称。这使得读者更容易理解在该类型的方法中使用接收器的方式。</p>
<br>

<blockquote>
<p><strong>NOTE：在 Go 语言中，短接收者名称的惯例与迄今为止提供的建议不一致。这只是早期做出的选择之一，已成为首选风格，就像使用 CamelCase 而不是 snake_case 一样。</strong></p>
</blockquote>
<br>

<blockquote>
<p><strong>TIP：Go 语言的风格规定接收者应具有单个字母名称或从其类型派生的首字母缩略词。你可能会发现接收者的名称有时会与方法中的参数名称冲突。在这种情况下，请考虑将参数名称稍微加长，并始终使用这个新参数名称。</strong></p>
</blockquote>
<br>

<p>最后，一些单字母变量传统上与循环和计数相关联。例如，i、j和k通常是简单for循环的循环归纳变量。n通常与计数器或累加器相关联。v是通用编码函数中值的常见缩写，k通常用于映射的键，s经常用作类型为字符串的参数的缩写。</p>
<br>

<p>与上面的db示例一样，程序员期望i是一个循环归纳变量。如果确保i始终是循环变量，在for循环之外不用于其他上下文中，读者遇到一个名为i或j的变量时，就知道循环就在附近。</p>
<br>

<blockquote>
<p><strong>TIP：如果你发现自己有太多的嵌套循环，以至于你用尽了i、j和k变量，那么现在可能是将函数分解为较小单元的时候了。</strong></p>
</blockquote>
<br>

<h3 id="2-5-使用一致的声明风格"><a href="#2-5-使用一致的声明风格" class="headerlink" title="2.5 使用一致的声明风格"></a>2.5 使用一致的声明风格</h3><br>

<p>Go至少有六种方式去声明一种变量</p>
<ul>
<li>  <code>var x int = 1</code></li>
<li>  <code>var x = 1</code></li>
<li>  <code>var x int; x = 1</code></li>
<li>  <code>var x = int(1)</code></li>
<li>  <code>x := 1</code></li>
</ul>
<br>

<p>我相信还有更多我没有想到的。这是Go语言的设计者们认为可能是一个错误，但现在已经太晚改变了。有了所有这些不同的变量声明方式，我们如何避免每个Go程序员选择自己的风格？</p>
<br>

<p>我想提出一个建议，介绍我在程序中如何声明变量。这是我尽可能使用的风格。</p>
<br>

<ul>
<li>  当声明变量但不初始化时，请使用 var。当声明一个变量，但稍后在函数中将明确初始化它时，请使用 var 关键字。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> players <span class="hljs-keyword">int</span>    <span class="hljs-comment">// 0</span><br><br><span class="hljs-keyword">var</span> things []Thing <span class="hljs-comment">// an empty slice of Things</span><br><br><span class="hljs-keyword">var</span> thing Thing    <span class="hljs-comment">// empty Thing struct</span><br>json.Unmarshall(reader, &amp;thing)<br></code></pre></td></tr></table></figure>

<br>

<p>var 关键字作为一个提示，表明这个变量已经被有意地声明为指定类型的零值。这也符合在包级别使用 var 关键字声明变量的要求，而不是使用短声明语法——尽管我稍后会主张你根本不应该使用包级别变量。</p>
<br>

<ul>
<li>  当声明并初始化变量时，请使用 :=。当同时声明并初始化变量时，也就是说我们不会让变量隐式地初始化为其零值，我建议使用短变量声明形式。这使得读者清楚地知道 := 左边的变量正在被有意地初始化。</li>
</ul>
<br>

<p>为了解释这个问题，让我们看一下之前的例子，但这次是有意地初始化每个变量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> players <span class="hljs-keyword">int</span> = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">var</span> things []Thing = <span class="hljs-literal">nil</span><br><br><span class="hljs-keyword">var</span> thing *Thing = <span class="hljs-built_in">new</span>(Thing)<br>json.Unmarshall(reader, thing)<br></code></pre></td></tr></table></figure>

<p>在第一个和第三个示例中，因为在 Go 中没有自动转换从一种类型到另一种类型，所以赋值操作符左边的类型必须与右边的类型相同。编译器可以从右侧的类型推断出被声明变量的类型，所以可以更简洁地写出示例，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> players = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">var</span> things []Thing = <span class="hljs-literal">nil</span><br><br><span class="hljs-keyword">var</span> thing = <span class="hljs-built_in">new</span>(Thing)<br>json.Unmarshall(reader, thing)<br></code></pre></td></tr></table></figure>

<p>这样我们就可以将 <code>players</code> 明确初始化为 0，但这是多余的，因为 0 是 <code>players</code> 的零值。因此，更好的方式是通过以下方式明确表明我们将使用零值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> players <span class="hljs-keyword">int</span><br></code></pre></td></tr></table></figure>

<p>那么第二个语句呢？我们不能省略类型，写成以下形式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> things = <span class="hljs-literal">nil</span><br><br></code></pre></td></tr></table></figure>

<p>因为 nil 没有类型。相反，我们有一个选择，我们想要一个切片的零值吗？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> things []Thing<br><br></code></pre></td></tr></table></figure>

<p>还是我们想要创建一个零元素的切片？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> things = <span class="hljs-built_in">make</span>([]Thing, <span class="hljs-number">0</span>)<br><br></code></pre></td></tr></table></figure>

<p>如果我们想要后者，那么这不是切片的零值，因此我们应该通过使用短声明形式明确告诉读者我们正在做出这个选择：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">things := <span class="hljs-built_in">make</span>([]Thing, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>

<p>这告诉读者我们选择明确初始化变量。</p>
<p>这让我们来看看第三个声明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> thing = <span class="hljs-built_in">new</span>(Thing)<br></code></pre></td></tr></table></figure>

<p>第三个声明同时明确初始化一个变量，并引入了 <code>new</code> 关键字的不常见用法，一些 Go 程序员不喜欢。如果我们应用我们的短声明语法建议，那么该语句变为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">thing := <span class="hljs-built_in">new</span>(Thing)<br></code></pre></td></tr></table></figure>

<p>这使得 thing 明确初始化为 new(Thing) 的结果——一个指向 Thing 的指针——但仍然存在 new 的不寻常用法。我们可以通过使用紧凑的结构体字面量初始化形式来解决这个问题，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">thing := &amp;Thing&#123;&#125;<br></code></pre></td></tr></table></figure>

<p>这与 <code>new(Thing)</code> 的效果相同，这就是为什么一些 Go 程序员会对重复感到不满。但这意味着我们正在使用指向 <code>Thing&#123;&#125;</code> 的指针来明确初始化 <code>thing</code>，这也是 <code>Thing</code> 的零值。</p>
<br>

<p>相反，我们应该认识到 <code>thing</code> 被声明为其零值，并使用取地址运算符将 <code>thing</code> 的地址传递给 <code>json.Unmarshall</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> thing Thing<br>json.Unmarshall(reader, &amp;thing)<br></code></pre></td></tr></table></figure>

<p>当然，对于任何经验法则，都有例外。例如，有时两个变量密切相关，因此编写以下内容可能会很奇怪：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> min <span class="hljs-keyword">int</span><br>max := <span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure>

<p>在这种情况下，声明可能更易读，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">min, max := <span class="hljs-number">0</span>, <span class="hljs-number">1000</span><br><br></code></pre></td></tr></table></figure>

<br>

<p>总之：</p>
<ul>
<li>  <strong>当声明一个未初始化的变量时，请使用</strong><code>var</code> 语法</li>
<li>  <strong>当声明并明确初始化变量时，请使用</strong><code>:=</code></li>
</ul>
<br>

<h3 id="2-6-成为一个团队合作者"><a href="#2-6-成为一个团队合作者" class="headerlink" title="2.6 成为一个团队合作者"></a>2.6 成为一个团队合作者</h3><br>

<p>我谈到了软件工程的一个目标是生产易读、易维护的代码。因此，你很可能会在你的职业生涯中大部分时间都在处理不是你独自编写的项目。我的建议是在这种情况下遵循当地的编码风格。</p>
<br>

<p>在文件的中间更改风格会让人感到不协调。即使不是你喜欢的方法，统一性对于维护比你的个人喜好更有价值。我的经验法则是：如果代码可以通过 <code>gofmt</code>，则通常不值得为此停止代码审查。（注：<code>gofmt</code> 是 Go 语言中自带的代码格式化工具）</p>
<br>

<blockquote>
<p>**TIP：如果你想在整个代码库中进行重命名，请不要将其与其他更改混在一起。如果有人正在使用 ****<code>git bisect</code>**<strong>，他们不想在找到你所更改的代码时浏览成千上万行的重命名代码。</strong></p>
</blockquote>
<br>

<h2 id="3-注释"><a href="#3-注释" class="headerlink" title="3. 注释"></a>3. 注释</h2><br>

<p>在我们继续处理更大的项目之前，我想花几分钟时间谈论一下注释。</p>
<br>

<blockquote>
<p><strong>“好的代码有很多注释，糟糕的代码需要很多注释。— Dave Thomas and Andrew Hunt”</strong></p>
</blockquote>
<br>

<p>注释对于 Go 程序的可读性非常重要。每个注释应该只做三件事中的一件：</p>
<ul>
<li>  注释应该解释这个东西是做什么的（explain <em>what</em> the thing does）</li>
<li>  注释应该解释这个东西是怎么做到它所做的事情的（explain <em>how</em> the thing does what it does）</li>
<li>  注释应该解释为什么这个东西是它所是的（explain <em>why</em> the thing is why it is）</li>
</ul>
<br>

<p>第一种形式最适合公共符号的注释：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Open opens the named file for reading. </span><br><span class="hljs-comment">// If successful, methods on the returned file can be used for reading. </span><br><br></code></pre></td></tr></table></figure>

<p>第二种形式最适合方法内的注释：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// queue all dependant actions</span><br><span class="hljs-keyword">var</span> results []<span class="hljs-keyword">chan</span> error<br><span class="hljs-keyword">for</span> _, dep := <span class="hljs-keyword">range</span> a.Deps &#123;<br>        results = <span class="hljs-built_in">append</span>(results, execute(seen, dep))<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第三种形式，即为什么，是独特的，因为它不会取代前两种，但同时它也不是对于 what 或 how 的替代。</p>
<br>

<p>为什么的注释风格存在的目的是为了解释驱动你在页面上读到的代码的外部因素。通常这些因素在没有上下文的情况下很难理解，注释的存在是为了提供上下文。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">return</span> &amp;v2.Cluster_CommonLbConfig&#123;<br>  <span class="hljs-comment">// Disable HealthyPanicThreshold</span><br>    HealthyPanicThreshold: &amp;envoy_type.Percent&#123;<br>      Value: <span class="hljs-number">0</span>,<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，设置 <code>HealthyPanicThreshold</code> 为零可能不会立即清楚会产生什么影响。注释是必需的，以澄清值为 0 将禁用 panic 阈值行为的含义。</p>
<br>

<h3 id="3-1-变量和常量的注释应该描述它们的内容，而不是它们的目的"><a href="#3-1-变量和常量的注释应该描述它们的内容，而不是它们的目的" class="headerlink" title="3.1 变量和常量的注释应该描述它们的内容，而不是它们的目的"></a>3.1 变量和常量的注释应该描述它们的内容，而不是它们的目的</h3><br>

<p>我之前说过，变量或常量的名称应该描述它们的目的。但是，当你给一个变量或常量添加注释时，注释应该描述变量的内容，而不是变量的目的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> randomNumber = <span class="hljs-number">6</span><br><br></code></pre></td></tr></table></figure>

<p>在这个例子中，注释描述了为什么randomNumber被赋值为6，以及6的来源。该注释并没有描述randomNumber将在哪里被使用。以下是一些更多的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    StatusContinue           = <span class="hljs-number">100</span> <span class="hljs-comment">// RFC 7231, 6.2.1</span><br>    StatusSwitchingProtocols = <span class="hljs-number">101</span> <span class="hljs-comment">// RFC 7231, 6.2.2</span><br>    StatusProcessing         = <span class="hljs-number">102</span> <span class="hljs-comment">// RFC 2518, 10.1</span><br><br>    StatusOK                 = <span class="hljs-number">200</span> <span class="hljs-comment">// RFC 7231, 6.3.1</span><br></code></pre></td></tr></table></figure>

<p>在HTTP的上下文中，数字100被称为”StatusContinue”，根据RFC 7231第6.2.1节的定义。</p>
<blockquote>
<p><strong>TIP：对于没有初始值的变量，注释应描述谁负责初始化该变量。</strong></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// sizeCalculationDisabled indicates whether it is safe</span><br><span class="hljs-comment">// to calculate Types&#x27; widths and alignments. See dowidth.</span><br><span class="hljs-keyword">var</span> sizeCalculationDisabled <span class="hljs-keyword">bool</span><br></code></pre></td></tr></table></figure>

<p>在这里，注释让读者知道<code>dowidth</code>函数负责维护<code>sizeCalculationDisabled</code>的状态。</p>
<br>

<p>隐形于明处。这是<strong>Kate Gregory</strong>提出的提示。有时您会发现一个更好的变量名隐藏在注释中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// registry of SQL drivers</span><br><span class="hljs-keyword">var</span> registry = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*sql.Driver)<br></code></pre></td></tr></table></figure>

<p>作者添加了注释，因为<code>registry</code>并不能充分解释它的目的——它是一个注册表，但是注册表的内容是什么？</p>
<p>通过将变量重命名为<code>sqlDrivers</code>，现在清楚了该变量的目的是保存SQL驱动程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> sqlDrivers = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*sql.Driver)<br></code></pre></td></tr></table></figure>

<p>现在注释已经多余了，可以将其删除。</p>
<br>

<h3 id="3-2-始终记录公共符号"><a href="#3-2-始终记录公共符号" class="headerlink" title="3.2 始终记录公共符号"></a>3.2 始终记录公共符号</h3><br>

<p>因为godoc是您的软件包的文档，您应该始终为软件包中声明的每个公共符号（变量、常量、函数和方法）添加注释。</p>
<br>

<p>以下是Google Style指南中的两个规则：</p>
<ul>
<li>  对于任何不够明显和简短的公共函数，必须添加注释</li>
<li>  对于库中的任何函数，无论长度或复杂程度如何，都必须添加注释</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> ioutil<br><br><span class="hljs-comment">// ReadAll reads from r until an error or EOF and returns the data it read.</span><br><span class="hljs-comment">// A successful call returns err == nil, not err == EOF. Because ReadAll is</span><br><span class="hljs-comment">// defined to read from src until EOF, it does not treat an EOF from Read</span><br><span class="hljs-comment">// as an error to be reported.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReadAll</span><span class="hljs-params">(r io.Reader)</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span><br></code></pre></td></tr></table></figure>

<p>这个规则有一个例外：您不需要记录实现接口的方法。具体而言，不要这样做：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Read implements the io.Reader interface</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *FileReader)</span> <span class="hljs-title">Read</span><span class="hljs-params">(buf []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span><br></code></pre></td></tr></table></figure>

<p>这个注释什么也没说。它没有告诉您方法的作用，实际上更糟糕的是，它告诉您去别处查找文档。在这种情况下，我建议完全删除注释。</p>
<br>

<p>以下是io包的一个示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// LimitReader returns a Reader that reads from r</span><br><span class="hljs-comment">// but stops with EOF after n bytes.</span><br><span class="hljs-comment">// The underlying implementation is a *LimitedReader.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LimitReader</span><span class="hljs-params">(r Reader, n <span class="hljs-keyword">int64</span>)</span> <span class="hljs-title">Reader</span></span> &#123; <span class="hljs-keyword">return</span> &amp;LimitedReader&#123;r, n&#125; &#125;<br><br><span class="hljs-comment">// A LimitedReader reads from R but limits the amount of</span><br><span class="hljs-comment">// data returned to just N bytes. Each call to Read</span><br><span class="hljs-comment">// updates N to reflect the new amount remaining.</span><br><span class="hljs-comment">// Read returns EOF when N &lt;= 0 or when the underlying R returns EOF.</span><br><span class="hljs-keyword">type</span> LimitedReader <span class="hljs-keyword">struct</span> &#123;<br>  R Reader <span class="hljs-comment">// underlying reader</span><br>  N <span class="hljs-keyword">int64</span>  <span class="hljs-comment">// max bytes remaining</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *LimitedReader)</span> <span class="hljs-title">Read</span><span class="hljs-params">(p []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-params">(n <span class="hljs-keyword">int</span>, err error)</span></span> &#123;<br>  <span class="hljs-keyword">if</span> l.N &lt;= <span class="hljs-number">0</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, EOF<br>  &#125;<br>  <span class="hljs-keyword">if</span> <span class="hljs-keyword">int64</span>(<span class="hljs-built_in">len</span>(p)) &gt; l.N &#123;<br>    p = p[<span class="hljs-number">0</span>:l.N]<br>  &#125;<br>  n, err = l.R.Read(p)<br>  l.N -= <span class="hljs-keyword">int64</span>(n)<br>  <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>请注意，<code>LimitedReader</code>的声明直接放在使用它的函数之前，而<code>LimitedReader.Read</code>的声明紧随<code>LimitedReader</code>本身的声明之后。尽管<code>LimitedReader.Read</code>本身没有文档说明，但可以清楚地看出它是<code>io.Reader</code>的一个实现。</p>
<br>

<blockquote>
<p><strong>TIP： 在编写函数之前，先写一个描述该函数的注释。如果您发现难以编写注释，那么这意味着您即将编写的代码将很难理解。</strong></p>
</blockquote>
<br>

<h4 id="3-2-1-不要注释糟糕的代码。直接重写"><a href="#3-2-1-不要注释糟糕的代码。直接重写" class="headerlink" title="3.2.1 不要注释糟糕的代码。直接重写"></a>3.2.1 不要注释糟糕的代码。直接重写</h4><blockquote>
<p><strong>“不要对糟糕的代码进行评论 - 重写它。— Brian Kernighan”</strong></p>
</blockquote>
<br>

<p>强调代码恶劣的注释并不足够。如果你遇到这样的注释，应该提出问题，以便稍后重构代码。只要知道了技术债务的数量，就可以接受它。</p>
<br>

<p>标准库的传统做法是在<code>TODO</code>样式的注释中注明注意到此问题的人的用户名。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// TODO(dfc) this is O(N^2), find a faster way to do this.</span><br></code></pre></td></tr></table></figure>

<p>用户名并不意味着那个人已经承诺解决这个问题，但在解决问题时可能是最好的问询对象。其他项目可能会用日期或问题编号注释<code>TODOs</code>。</p>
<br>

<h4 id="3-2-2-与其注释一块代码，不如重构它"><a href="#3-2-2-与其注释一块代码，不如重构它" class="headerlink" title="3.2.2 与其注释一块代码，不如重构它"></a>3.2.2 与其注释一块代码，不如重构它</h4><br>

<blockquote>
<p><strong>“良好的代码是最好的文档。在你要添加注释之前，问问自己，“我如何改进代码，使得不需要这个注释？”改进代码，然后再进行文档说明，以使其更加清晰明了。——Steve McConnell”</strong></p>
</blockquote>
<br>

<p>函数应该只做一件事情。如果你发现自己在对一段代码进行注释，因为它与函数的其余部分无关，请考虑将其提取为一个独立的函数。</p>
<br>

<p>除了更容易理解外，更小的函数也更容易在隔离测试中测试。一旦你将正交的代码隔离成自己的函数，它的名称可能是唯一需要的文档说明。</p>
<br>

<h2 id="4-包设计"><a href="#4-包设计" class="headerlink" title="4.包设计"></a>4.包设计</h2><br>

<blockquote>
<p><strong>“写“内敛代码” - 模块不会向其他模块透露任何不必要的信息，并且不依赖于其他模块的实现。—Dave Thomas”</strong></p>
</blockquote>
<br>

<p>每个 Go 包实际上都是自己的小型 Go 程序。就像函数或方法的实现对调用者不重要一样，组成包公共 API 的函数、方法和类型的实现 - 它的行为 - 对于调用者也不重要。</p>
<br>

<p>一个好的 Go 包应该努力实现低源代码耦合度，这样，随着项目的增长，对一个包的更改不会在整个代码库中产生级联效应。这些全局重构将对代码库中成员的生产率产生严格的限制。</p>
<br>

<p>在本节中，我们将讨论设计包 - 包括包的名称 - 命名类型以及编写方法和函数的技巧。</p>
<br>

<h3 id="4-1-一个好的包起始于它的名字"><a href="#4-1-一个好的包起始于它的名字" class="headerlink" title="4.1 一个好的包起始于它的名字"></a>4.1 一个好的包起始于它的名字</h3><br>

<p>编写一个好的Go包，从包的名称开始。将您的包的名称视为使用一个单词描述其功能的电梯推销。</p>
<br>

<p>就像我在前面的部分谈到变量名称一样，包的名称非常重要。我遵循的经验法则不是“我应该在这个包中放什么类型？”。相反，我问的问题是“这个包提供了什么服务？”通常，答案不是“这个包提供了X类型”，而是“这个包让你说HTTP”。</p>
<br>

<blockquote>
<p><strong>TIP：按提供的功能来命名您的包，而不是其所包含的内容。</strong></p>
</blockquote>
<br>

<h4 id="4-1-1-好的包名应该是唯一的"><a href="#4-1-1-好的包名应该是唯一的" class="headerlink" title="4.1.1 好的包名应该是唯一的"></a>4.1.1 好的包名应该是唯一的</h4><br>

<p>在您的项目中，每个包名都应该是唯一的。如果您按照包的名称应该基于其用途的建议，则应该很容易做到这一点。如果您发现有两个需要相同名称的包，则可能是以下情况之一：</p>
<ul>
<li>  包名过于通用。</li>
<li>  该包与另一个类似名称的包重叠。在这种情况下，您应该检查您的设计，或者考虑合并这些包。</li>
</ul>
<br>

<h3 id="4-2-避免像base-common或者util的包命名"><a href="#4-2-避免像base-common或者util的包命名" class="headerlink" title="4.2 避免像base common或者util的包命名"></a>4.2 避免像<code>base</code> <code>common</code>或者<code>util</code>的包命名</h3><br>

<p>常见的糟糕包名的一个原因是所谓的实用程序包。这些包是由于通用助手和实用代码随时间而凝结而成的。由于这些包包含了各种不相关的函数，因此很难用该包提供的内容来描述其实用性。这经常导致该包的名称来自于该包所包含的实用程序。</p>
<br>

<p>在较大的项目中，像 <code>utils</code> 或 <code>helpers</code> 这样的包名很常见，这些项目具有深层的包层次结构，并希望在遇到导入循环时共享帮助函数。通过将实用函数提取到新包中，可以打破导入循环，但由于该包源于项目中的设计问题，其名称并不反映其目的，只反映其打破导入循环的功能。</p>
<br>

<p>我建议改进 utils 或 helpers 包的名称，是分析它们被调用的位置，并尽可能将相关函数移动到其调用者的包中。即使这涉及到复制一些助手代码，这也比在两个包之间引入导入依赖要好。</p>
<br>

<blockquote>
<p><strong>“少量的重复比错误的抽象成本要便宜得多。 —— Sandy Metz”</strong></p>
</blockquote>
<br>

<p>在多个地方使用实用函数的情况下，应该优先选择多个包，每个包专注于一个单一方面，而不是单个的大包。</p>
<br>

<blockquote>
<p><strong>TIP： 使用复数来命名实用程序包。例如，字符串处理实用程序的包名为 strings。</strong></p>
</blockquote>
<br>

<p>当两个或多个实现共用的功能或客户端和服务器的共同类型已被重构为一个单独的包时，通常会出现名为 <code>base</code> 或 <code>common</code> 的包名。我认为解决这个问题的方法是减少包的数量，将客户端、服务器和公共代码组合成一个以包的功能命名的单一包。</p>
<br>

<p>例如，<code>net/http</code> 包没有客户端和服务器子包，而是有一个 <code>client.go</code> 和 <code>server.go</code> 文件，每个文件分别包含其各自的类型，以及一个 <code>transport.go</code> 文件，用于共同的消息传输代码。</p>
<br>

<blockquote>
<p><strong>TIP： 标识符的名称包括其包名称。 重要的是要记住，标识符的名称包括其包的名称。</strong></p>
</blockquote>
<br>

<ul>
<li>  当另一个包引用 net/http 包中的 Get 函数时，它变成了 http.Get。</li>
<li>  从 strings 包导入的 Reader 类型变成了 strings.Reader。</li>
<li>  net 包中的 Error 接口明显与网络错误相关联。</li>
</ul>
<br>

<h3 id="4-3-尽早返回，而不要深层嵌套"><a href="#4-3-尽早返回，而不要深层嵌套" class="headerlink" title="4.3 尽早返回，而不要深层嵌套"></a>4.3 尽早返回，而不要深层嵌套</h3><br>

<p>由于Go语言不使用异常进行控制流，因此没有必要深度缩进代码，只是为了为<code>try</code>和<code>catch</code>块提供顶层结构。与其让成功路径嵌套得越来越深，Go代码的编写风格是，成功路径会随着函数的进展而沿着屏幕向下延伸。我的朋友<strong>Mat Ryer</strong>称这种做法为“视线”编码。</p>
<br>

<p>这是通过使用**<code>guard clauses</code>**实现的；这些条件块在进入函数时具有断言前提条件。以下是<code>bytes</code>包的一个示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Buffer)</span> <span class="hljs-title">UnreadRune</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br>  <span class="hljs-keyword">if</span> b.lastRead &lt;= opInvalid &#123;<br>    <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune&quot;</span>)<br>  &#125;<br>  <span class="hljs-keyword">if</span> b.off &gt;= <span class="hljs-keyword">int</span>(b.lastRead) &#123;<br>    b.off -= <span class="hljs-keyword">int</span>(b.lastRead)<br>  &#125;<br>  b.lastRead = opInvalid<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<p>进入<code>UnreadRune</code>函数时，会检查<code>b.lastRead</code>的状态，如果先前的操作不是<code>ReadRune</code>，则会立即返回一个错误。从那里开始，函数的其余部分将断言<code>b.lastRead</code>大于<code>opInvalid</code>。</p>
<br>

<p>相比之下，如果不使用保护子句编写相同的函数，则会不同。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Buffer)</span> <span class="hljs-title">UnreadRune</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br>  <span class="hljs-keyword">if</span> b.lastRead &gt; opInvalid &#123;<br>    <span class="hljs-keyword">if</span> b.off &gt;= <span class="hljs-keyword">int</span>(b.lastRead) &#123;<br>      b.off -= <span class="hljs-keyword">int</span>(b.lastRead)<br>    &#125;<br>    b.lastRead = opInvalid<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>成功情况下的代码块通常嵌套在第一个if条件语句内部，并且成功退出的条件（即返回nil）必须通过仔细匹配闭括号来确定。现在函数的最后一行返回一个错误，调用者必须追踪函数的执行过程，以知道何时控制流程将到达该点的匹配开括号。</p>
<br>

<p>这对于读者和维护程序员来说更容易出错，这就是为什么Go更喜欢使用<code>guard clauses</code>并在出现错误时提前返回。</p>
<br>

<h3 id="4-4-使零值变得有用"><a href="#4-4-使零值变得有用" class="headerlink" title="4.4 使零值变得有用"></a>4.4 使零值变得有用</h3><p>每个变量声明，如果没有提供明确的初始化器，将自动初始化为与清零内存的内容相匹配的值，这是该值的零值。该值的类型决定了该值的零值；对于数值类型，它是零，对于指针类型为nil，对于<code>slices</code>、<code>maps</code>和<code>channels</code>也是如此。</p>
<br>

<p>这种总是将值设置为已知默认值的特性对于程序的安全性和正确性非常重要，可以使您的Go程序更简单、更紧凑。这就是Go程序员谈论“给您的结构体一个有用的零值”时所说的内容。</p>
<br>

<p>考虑<code>sync.Mutex</code>类型。<code>sync.Mutex</code>包含两个未导出的整数字段，表示互斥锁的内部状态。由于零值的存在，每当声明<code>sync.Mutex</code>时，这些字段将被设置为0。<code>sync.Mutex</code>已经被有意地编写，以利用这个属性，使该类型在没有明确初始化的情况下可用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-keyword">struct</span> &#123;<br>  mu  sync.Mutex<br>  val <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">var</span> i MyInt<br><br>  <span class="hljs-comment">// i.mu is usable without explicit initialisation.</span><br>  i.mu.Lock()<br>  i.val++<br>  i.mu.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>另一个具有有用的零值类型的示例是 <code>bytes.Buffer</code>。您可以声明一个 <code>bytes.Buffer</code> 并开始向其写入，而无需进行显式初始化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">var</span> b bytes.Buffer<br>  b.WriteString(<span class="hljs-string">&quot;Hello, world!\n&quot;</span>)<br>  io.Copy(os.Stdout, &amp;b)<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>切片（<code>slices</code>）的一个有用属性是它们的零值为 nil。如果我们查看运行时对切片头的定义，这是有意义的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span> &#123;<br>        array *[...]T <span class="hljs-comment">// pointer to the underlying array</span><br>        <span class="hljs-built_in">len</span>   <span class="hljs-keyword">int</span><br>        <span class="hljs-built_in">cap</span>   <span class="hljs-keyword">int</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>该结构体的零值意味着 len 和 cap 的值为0，而 array（指向持有切片的后备数组的内存的指针）将为 nil。这意味着您无需显式地创建切片，只需声明即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">// s := make([]string, 0)</span><br>  <span class="hljs-comment">// s := []string&#123;&#125;</span><br>  <span class="hljs-keyword">var</span> s []<span class="hljs-keyword">string</span><br><br>  s = <span class="hljs-built_in">append</span>(s, <span class="hljs-string">&quot;Hello&quot;</span>)<br>  s = <span class="hljs-built_in">append</span>(s, <span class="hljs-string">&quot;world&quot;</span>)<br>  fmt.Println(strings.Join(s, <span class="hljs-string">&quot; &quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p><strong>NOTE：</strong><strong><code>var s []string</code></strong>** 与其上方两行注释的代码类似，但并不完全相同。可以区分一个 nil 值的切片和一个长度为零的切片。以下代码将输出 false。**</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">var</span> s1 = []<span class="hljs-keyword">string</span>&#123;&#125;<br>  <span class="hljs-keyword">var</span> s2 []<span class="hljs-keyword">string</span><br>  fmt.Println(reflect.DeepEqual(s1, s2)) <span class="hljs-comment">// false</span><br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<p><strong>未初始化的指针变量（空指针）的一个有用但令人惊讶的特性是，您可以在具有空值的类型上调用方法。这可以用于简单地提供默认值。</strong></p>
<br>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Config <span class="hljs-keyword">struct</span> &#123;<br>  path <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Config)</span> <span class="hljs-title">Path</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br>  <span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/usr/home&quot;</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> c.path<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">var</span> c1 *Config<br>  <span class="hljs-keyword">var</span> c2 = &amp;Config&#123;<br>    path: <span class="hljs-string">&quot;/export&quot;</span>,<br>  &#125;<br>  fmt.Println(c1.Path(), c2.Path())<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="4-5-避免在包级别使用状态"><a href="#4-5-避免在包级别使用状态" class="headerlink" title="4.5 避免在包级别使用状态"></a>4.5 避免在包级别使用状态</h3><br>

<p>编写易于维护的程序的关键在于它们应该松耦合 - 对一个包的更改应该很少影响那些不直接依赖于该包的其他包。</p>
<br>

<p>在Go中有两种优秀的方法可以实现松耦合：</p>
<ul>
<li>  使用接口来描述函数或方法所需的行为</li>
<li>  避免使用全局状态</li>
</ul>
<br>

<p>在Go中，我们可以在函数或方法作用域以及包作用域声明变量。当变量是公共的，并以大写字母开头的标识符给出时，它的作用域对于整个程序实际上是全局的 - 任何包都可以随时观察该变量的类型和内容。</p>
<br>

<p><strong>可变的全局状态会在程序的独立部分之间引入紧密耦合，因为全局变量成为程序中每个函数的不可见参数！如果该变量的类型发生更改，则任何依赖于全局变量的函数都可能出错。如果程序的另一部分更改了该变量的状态，那么依赖于全局变量状态的任何函数都可能出错。</strong></p>
<br>

<p>如果您想减少全局变量创建的耦合：</p>
<ul>
<li>  将相关变量作为需要它们的结构体字段移动。</li>
<li>  使用接口来减少行为与行为实现之间的耦合。</li>
</ul>
<br>

<h2 id="5-项目结构"><a href="#5-项目结构" class="headerlink" title="5. 项目结构"></a>5. 项目结构</h2><br>

<p>让我们谈谈将多个包合并到一个项目中。通常这将是一个单一的git存储库。在未来，Go开发人员将可以互换使用术语模块和项目。</p>
<br>

<p>与包一样，每个项目都应该有明确的目的。如果您的项目是一个库，它应该提供一个功能，例如XML解析或日志记录。您应该避免将多个目的合并到一个项目中，这将有助于避免可怕的通用库。</p>
<br>

<blockquote>
<p>**TIP：根据我的经验，通用存储库最终会与它最大的使用者紧密耦合在一起，这使得在同时升级通用存储库和使用者非常困难，带来许多无关的更改和API破坏。 **</p>
</blockquote>
<br>

<p>如果您的项目是一个应用程序，例如您的Web应用程序、Kubernetes控制器等，则您的项目中可能有一个或多个主要包。例如，我工作的Kubernetes控制器有一个名为cmd/contour的单一包，既可以作为部署到Kubernetes集群的服务器，也可以作为用于调试的客户端。</p>
<br>

<h3 id="5-1-考虑的越少，包就会越大"><a href="#5-1-考虑的越少，包就会越大" class="headerlink" title="5.1 考虑的越少，包就会越大"></a>5.1 考虑的越少，包就会越大</h3><br>

<p>在程序员从其他语言转向Go语言的代码审查中，我经常发现他们倾向于过度使用包。</p>
<br>

<p>Go语言没有提供建立可见性的详细方法。Go语言缺少Java中的public、protected、private和隐式默认访问修饰符。也没有类似于C++中友元类的概念。</p>
<br>

<p>在Go语言中，我们只有两个访问修饰符：公共和私有，由标识符的首字母大小写表示。如果一个标识符是公共的，它的名字以大写字母开头，那么它可以被任何其他的Go包引用。</p>
<br>

<blockquote>
<p><strong>NOTE：你可能会听到人们将“导出的（exported）”和“未导出的（not exported）”视为公共和私有的同义词。</strong></p>
</blockquote>
<br>

<p>由于控制访问包符号的受限，Go程序员应该遵循什么样的做法来避免创建过于复杂的包层次结构呢？</p>
<br>

<blockquote>
<p><strong>TIP：除了cmd/和internal/之外，每个包都应该包含一些源代码。</strong></p>
</blockquote>
<br>

<p>我发现自己经常重复的建议是，最好使用更少、更大的包。你的默认立场应该是不创建新的包。这会导致太多类型被公开，从而为包创建了一个宽而浅的API表面。</p>
<br>

<p>下面的部分会更详细地探讨这个建议。</p>
<br>

<p>如果你来自Java背景？<br>如果你来自Java或C#背景，请考虑以下经验法则：</p>
<ul>
<li>  一个Java包等同于单个.go源文件。</li>
<li>  一个Go包相当于一个完整的Maven模块或.NET程序集。</li>
</ul>
<br>

<h4 id="5-1-1-将代码按照导入语句分组成不同的文件"><a href="#5-1-1-将代码按照导入语句分组成不同的文件" class="headerlink" title="5.1.1 将代码按照导入语句分组成不同的文件"></a>5.1.1 将代码按照导入语句分组成不同的文件</h4><br>

<p>如果您按照Go包向调用方提供的内容来编排包，那么是否应该对Go包中的文件进行相同的编排呢？您如何知道何时应将.go文件拆分为多个文件？您如何知道何时已经走得太远，应该考虑合并.go文件？</p>
<br>

<p>以下是我使用的指导：</p>
<ul>
<li>  每个Go包都应该以一个.go文件开始。给这个文件和文件夹相同的名称。例如，名为http的包应该被放置在名为http.go的文件夹中。</li>
<li>  随着您的包的增长，您可能会决定将各种职责拆分到不同的文件中。例如，messages.go 包含请求和响应类型，client.go包含客户端类型，server.go包含服务器类型。</li>
<li>  如果您发现您的文件具有相似的import声明，请考虑将它们合并。或者，找出import集之间的差异并将它们移动。</li>
<li>  不同的文件应该负责包的不同区域。例如，messages.go 可能负责在网络上对HTTP请求和响应进行编组和解组，http.go 可能包含低级网络处理逻辑，client.go 和 server.go实现请求构造或路由的HTTP业务逻辑，等等。</li>
</ul>
<br>

<blockquote>
<p><strong>TIP：建议使用名词作为源文件名</strong></p>
</blockquote>
<br>

<blockquote>
<p><strong>NOTE：Go编译器并行编译每个包。在一个包中，编译器并行编译每个函数（在Go中，方法只是一种比较高级的函数）。在包内改变代码布局不应该影响编译时间。</strong></p>
</blockquote>
<br>

<h4 id="5-1-2-倾向于内部测试而非外部测试"><a href="#5-1-2-倾向于内部测试而非外部测试" class="headerlink" title="5.1.2 倾向于内部测试而非外部测试"></a>5.1.2 倾向于内部测试而非外部测试</h4><p>go工具支持在两个位置编写测试包测试。假设你的包名为http2，你可以编写一个http2_test.go文件并使用http2包声明。这样做将把http2_test.go中的代码编译为http2包的一部分。这被俗称为内部测试。</p>
<br>

<p>go工具还支持特殊的包声明，以test结尾，例如http_test包。这允许你的测试文件与你的代码在同一个包中，但是当这些测试被编译时，它们不是你包的代码的一部分，而是存在于它们自己的包中。这允许你编写测试，就好像你是另一个包在调用你的代码。这被称为外部测试。</p>
<br>

<p>我建议在为你的包编写单元测试时使用内部测试。这允许你直接测试每个函数或方法，避免了外部测试的繁文缛节。</p>
<br>

<p>但是，你应该将你的示例测试函数放在外部测试文件中。这确保了当在godoc中查看时，示例具有适当的包前缀，可以轻松复制粘贴。</p>
<br>

<blockquote>
<p><strong>TIP：避免复杂的包层次结构，抵制应用分类法的欲望 除了我们接下来要谈论的一个例外情况，Go包的层次结构对于go工具没有意义。例如，net/http包不是net包的子包或子目录。</strong></p>
</blockquote>
<br>

<p>如果你发现在你的项目中创建了不包含.go文件的中间目录，那么你可能没有遵循这个建议。</p>
<br>

<h4 id="5-1-3-使用内部包来减少您的公共API表面"><a href="#5-1-3-使用内部包来减少您的公共API表面" class="headerlink" title="5.1.3 使用内部包来减少您的公共API表面"></a>5.1.3 使用内部包来减少您的公共API表面</h4><br>

<p>如果您的项目包含多个包，您可能会发现一些导出函数是供其他包使用的，但不打算成为项目的公共API的一部分。如果您发现自己处于这种情况，go工具可以识别一个特殊的文件夹名称 - 不是包名称 - <code>internal/</code>，用于放置公共于您的项目，但对其他项目来说是私有的代码。</p>
<br>

<p>要创建这样的包，请将其放置在名为internal/的目录中，或在名为<code>internal/</code>的目录的子目录中。当go命令看到路径中带有<code>internal</code>的包的导入时，它会验证进行导入的包是否在以internal目录的父目录为根的树中。</p>
<br>

<p>例如，包<code>.../a/b/c/internal/d/e/f</code>只能由根为<code>.../a/b/c</code>的目录树中的代码导入。它不能被<code>.../a/b/g</code>或任何其他存储库中的代码导入。</p>
<br>

<h3 id="5-2-保持main包尽可能的小"><a href="#5-2-保持main包尽可能的小" class="headerlink" title="5.2 保持main包尽可能的小"></a>5.2 保持<code>main</code>包尽可能的小</h3><br>

<p>您的主要功能和主要包应尽可能少地执行操作。这是因为 <code>main.main</code> 充当单例；程序中只能有一个 <code>main</code> 函数，包括测试。</p>
<br>

<p>由于 <code>main.main</code> 是一个单例，因此在<code>main.main</code> 调用的东西中内置了许多假设，即它们只会在 main.main 或 main.init 中调用，并且仅调用一次。这使得很难为在 main.main 中编写的代码编写测试，因此您应该尽量将尽可能多的业务逻辑移出主函数，最好移出主包。</p>
<br>

<blockquote>
<p><strong>TIP：func main() 应解析标志、打开到数据库、记录器等的连接，然后将执行权移交给一个高级对象。</strong></p>
</blockquote>
<br>

<h2 id="6-API设计"><a href="#6-API设计" class="headerlink" title="6. API设计"></a>6. API设计</h2><br>

<p>我今天要给出的最后一个设计建议，我觉得是最重要的。</p>
<br>

<p>到目前为止，我所提出的所有建议都只是建议。这些是我尝试编写Go的方式，但我不会在代码审查中强行推动它们。</p>
<br>

<p>然而，当涉及到在代码审查期间审查API时，我就不那么宽容了。这是因为我到目前为止谈论的所有内容都可以在不破坏向后兼容性的情况下进行修复；它们在很大程度上是实现细节。</p>
<br>

<p>当涉及到一个包的公共API时，考虑其初始设计是值得的，因为稍后更改该设计将对已经使用您的API的人造成干扰。</p>
<br>

<h3 id="6-1-设计难以被误用的API"><a href="#6-1-设计难以被误用的API" class="headerlink" title="6.1 设计难以被误用的API"></a>6.1 设计难以被误用的API</h3><br>

<blockquote>
<p><strong>“API应该易于使用且难以被误用。— Josh Bloch”</strong></p>
</blockquote>
<br>

<p>如果您从本次演示中获得了任何收获，那就应该是<code>Josh Bloch</code>的这条建议。如果一个API对于简单的事情使用起来很困难，那么每次调用API都会看起来很复杂。当API的实际调用变得复杂时，它将变得不太明显，更容易被忽视。</p>
<br>

<h4 id="6-1-1-要谨慎使用需要多个同类型参数的函数"><a href="#6-1-1-要谨慎使用需要多个同类型参数的函数" class="headerlink" title="6.1.1 要谨慎使用需要多个同类型参数的函数"></a>6.1.1 要谨慎使用需要多个同类型参数的函数</h4><br>

<p>一个看起来简单但正确使用起来很困难的API的一个好例子是需要两个或多个相同类型参数的函数。让我们比较两个函数签名：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Max</span><span class="hljs-params">(a，b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span> <span class="hljs-title">func</span> <span class="hljs-title">CopyFile</span><span class="hljs-params">(to，from <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span><br></code></pre></td></tr></table></figure>

<p>这两个函数有什么区别？显然，一个返回两个数中的最大值，另一个则是复制一个文件，但这并不是最重要的事情。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">Max（<span class="hljs-number">8</span>, <span class="hljs-number">10</span>）<span class="hljs-comment">// 10 </span><br>Max（<span class="hljs-number">10</span>, <span class="hljs-number">8</span>）<span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure>

<p>Max是可交换的，它的参数顺序不影响结果。无论我比较8和10还是10和8，八和十的最大值都是十。</p>
<br>

<p>但是，这个属性对于CopyFile来说并不成立。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">CopyFile（“/tmp/backup”，“presentation.md”）<br>CopyFile（“presentation.md”, “/tmp/backu“）<br></code></pre></td></tr></table></figure>

<p>其中哪个语句备份了您的演示文稿，哪个覆盖了您的演示文稿并恢复了上周的版本？您需要查看文档才能确定，代码审阅人员也无法确定您的参数是否正确而不查看文档。</p>
<br>

<p>解决这个问题的一种方法是引入一个辅助类型，负责正确地调用CopyFile。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Source <span class="hljs-keyword">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(src Source)</span> <span class="hljs-title">CopyTo</span><span class="hljs-params">(dest <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<br>  <span class="hljs-keyword">return</span> CopyFile(dest, <span class="hljs-keyword">string</span>(src))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">var</span> from Source = <span class="hljs-string">&quot;presentation.md&quot;</span><br>  from.CopyTo(<span class="hljs-string">&quot;/tmp/backup&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样，CopyFile总是被正确地调用——这可以通过单元测试进行验证——并且可能被设置为私有的，进一步降低误用的可能性。</p>
<br>

<blockquote>
<p><strong>TIP：带有多个相同类型参数的API很难正确使用。</strong></p>
</blockquote>
<br>

<h3 id="6-2-默认情况下的APIs设计"><a href="#6-2-默认情况下的APIs设计" class="headerlink" title="6.2 默认情况下的APIs设计"></a>6.2 默认情况下的APIs设计</h3><br>

<p>几年前，我曾经就使用函数选项来使API在其默认情况下更易于使用发表过演讲。</p>
<br>

<p>这个演讲的要点是，你应该为常见的使用情况设计你的API。换句话说，你的API不应该要求调用者提供他们不关心的参数。</p>
<br>

<h4 id="6-2-1-不鼓励将nil作为参数使用"><a href="#6-2-1-不鼓励将nil作为参数使用" class="headerlink" title="6.2.1 不鼓励将nil作为参数使用"></a>6.2.1 不鼓励将nil作为参数使用</h4><br>

<p>我在本章开头提出了这样一个建议，即当调用方不关心参数的含义时，你不应该强制要求其提供参数。这就是我所说的为其默认使用情况设计API。</p>
<br>

<p>这里有一个来自net/http包的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> http<br><br><span class="hljs-comment">// ListenAndServe listens on the TCP network address addr and then calls</span><br><span class="hljs-comment">// Serve with handler to handle requests on incoming connections.</span><br><span class="hljs-comment">// Accepted connections are configured to enable TCP keep-alives.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The handler is typically nil, in which case the DefaultServeMux is used.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// ListenAndServe always returns a non-nil error.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ListenAndServe</span><span class="hljs-params">(addr <span class="hljs-keyword">string</span>, handler Handler)</span> <span class="hljs-title">error</span></span> &#123;&#125;<br></code></pre></td></tr></table></figure>

<p><code>ListenAndServe</code>函数有两个参数，一个TCP地址用于监听传入连接，和一个http.Handler用于处理传入的HTTP请求。Serve函数允许第二个参数为nil，并注明通常调用方会传递nil表示他们希望使用http.DefaultServeMux作为隐含参数。</p>
<br>

<p>现在，Serve的调用方有两种方法可以做同样的事情。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">http.ListenAndServe(<span class="hljs-string">&quot;0.0.0.0:8080&quot;</span>, <span class="hljs-literal">nil</span>) <br>http.ListenAndServe(<span class="hljs-string">&quot;0.0.0.0:8080&quot;</span>, http.DefaultServeMux)<br><br></code></pre></td></tr></table></figure>

<p>两者都完全相同。</p>
<br>

<p>这种nil行为是有传染性的。<code>http</code>包还有一个<code>http.Serve</code>辅助函数，你可以合理地想象<code>ListenAndServe</code>像这样构建：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ListenAndServe</span><span class="hljs-params">(addr <span class="hljs-keyword">string</span>, handler Handler)</span> <span class="hljs-title">error</span></span> &#123;<br>  l, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, addr)<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> err<br>  &#125;<br>  <span class="hljs-keyword">defer</span> l.Close()<br>  <span class="hljs-keyword">return</span> Serve(l, handler)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>因为<code>ListenAndServe</code>允许调用方将第二个参数传递为<code>nil</code>，<code>http.Serve</code>也支持这种行为。实际上，<code>http.Serve</code>是实现“如果handler为nil，则使用<code>DefaultServeMux</code>”的逻辑的函数。接受一个参数为nil可能会导致调用方认为他们可以将两个参数都传递为nil。然而，像这样调用<code>Serve</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">http.Serve(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>) <br></code></pre></td></tr></table></figure>

<p>将导致一个难看的<code>panic</code>错误。</p>
<br>

<blockquote>
<p><strong>TIP：不要在同一个函数签名中混合使用nil和非nil参数。</strong></p>
</blockquote>
<br>

<p><code>http.ListenAndServe</code>的作者试图在常见情况下使API用户的生活更轻松，但可能使包难以安全使用。</p>
<br>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> root = http.Dir(<span class="hljs-string">&quot;/htdocs&quot;</span>)<br>http.Handle(<span class="hljs-string">&quot;/&quot;</span>, http.FileServer(root))<br>http.ListenAndServe(<span class="hljs-string">&quot;0.0.0.0:8080&quot;</span>, <span class="hljs-literal">nil</span>)<br></code></pre></td></tr></table></figure>

<br>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> root = http.Dir(<span class="hljs-string">&quot;/htdocs&quot;</span>)<br>http.Handle(<span class="hljs-string">&quot;/&quot;</span>, http.FileServer(root))<br>http.ListenAndServe(<span class="hljs-string">&quot;0.0.0.0:8080&quot;</span>, http.DefaultServeMux)<br></code></pre></td></tr></table></figure>

<br>

<p>这样做是否值得一行代码的混淆？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> root = http.Dir(<span class="hljs-string">&quot;/htdocs&quot;</span>)<br>mux := http.NewServeMux()<br>mux.Handle(<span class="hljs-string">&quot;/&quot;</span>, http.FileServer(root))<br>http.ListenAndServe(<span class="hljs-string">&quot;0.0.0.0:8080&quot;</span>, mux)<br></code></pre></td></tr></table></figure>

<br>

<blockquote>
<p><strong>TIP：认真考虑帮助函数将为程序员节省多少时间。清晰比简洁更好。</strong></p>
</blockquote>
<br>

<blockquote>
<p><strong>TIP：避免具有仅限测试参数的公共API</strong></p>
</blockquote>
<br>

<p>避免暴露具有仅在测试范围内不同的值的API。相反，使用公共包装器隐藏这些参数，使用测试范围的辅助函数在测试范围内设置属性。</p>
<br>

<h4 id="6-2-2-建议使用可变参数（var-args）而不是-T-类型的参数"><a href="#6-2-2-建议使用可变参数（var-args）而不是-T-类型的参数" class="headerlink" title="6.2.2 建议使用可变参数（var args）而不是 []T 类型的参数"></a>6.2.2 建议使用可变参数（var args）而不是 []T 类型的参数</h4><p>很常见的情况是编写一个接受值切片的函数或方法，例如下面这个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ShutdownVMs</span><span class="hljs-params">(ids []<span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> <br></code></pre></td></tr></table></figure>

<p>我只是举了一个例子，但这种情况在我工作的许多代码中都很常见。</p>
<br>

<p>这种函数签名的问题在于它们假定会调用多个条目。但是，我发现很多时候这些类型的函数只使用一个参数进行调用，这就需要将这个参数“装箱”到一个切片中以符合函数签名的要求。</p>
<br>

<p>此外，因为ids参数是一个切片，你可以将一个空切片或nil传递给函数，编译器也不会报错。这增加了额外的测试负担，因为你需要在测试中涵盖这些情况。</p>
<br>

<p>举个例子，最近我正在重构一段逻辑，如果一组参数中至少有一个非零，则需要设置一些额外的字段。这段逻辑看起来像这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> svc.MaxConnections &gt; <span class="hljs-number">0</span> || svc.MaxPendingRequests &gt; <span class="hljs-number">0</span> || svc.MaxRequests &gt; <span class="hljs-number">0</span> || svc.MaxRetries &gt; <span class="hljs-number">0</span> &#123;<br>  <span class="hljs-comment">// apply the non zero parameters</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于 if 语句变得非常长，我想将检查逻辑提取到自己的函数中。这就是我想出来的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// anyPostive indicates if any value is greater than zero.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">anyPositive</span><span class="hljs-params">(values ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>  <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>    <span class="hljs-keyword">if</span> v &gt; <span class="hljs-number">0</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这使我能够清楚地向读者表明内部块将被执行的条件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> anyPositive(svc.MaxConnections, svc.MaxPendingRequests, svc.MaxRequests, svc.MaxRetries) &#123;<br>        <span class="hljs-comment">// apply the non zero parameters</span><br>&#125;<br><br></code></pre></td></tr></table></figure>



<p>然而，anyPositive 存在一个问题，有些人可能会意外地这样调用它：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> anyPositive() &#123; ... &#125;<br></code></pre></td></tr></table></figure>

<p>在这种情况下，anyPositive 将返回 false，因为它将执行零次迭代并立即返回 false。这并不是世界上最糟糕的事情，最糟糕的是当 anyPositive 没有传入参数时返回 true。</p>
<br>

<p>尽管如此，如果我们能够更改 anyPositive 的签名以强制调用者至少传递一个参数，那将会更好。我们可以通过组合普通参数和可变参数来实现这一点，像这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// anyPostive indicates if any value is greater than zero.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">anyPositive</span><span class="hljs-params">(first <span class="hljs-keyword">int</span>, rest ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>  <span class="hljs-keyword">if</span> first &gt; <span class="hljs-number">0</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125;<br>  <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> rest &#123;<br>    <span class="hljs-keyword">if</span> v &gt; <span class="hljs-number">0</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在 anyPositive 不能使用少于一个参数进行调用。</p>
<br>

<h3 id="6-3-让函数定义它们所需的行为"><a href="#6-3-让函数定义它们所需的行为" class="headerlink" title="6.3 让函数定义它们所需的行为"></a>6.3 让函数定义它们所需的行为</h3><br>

<p>让我们假设我被分配了一个任务，要编写一个将 Document 结构保存到磁盘的函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Save writes the contents of doc to the file f.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Save</span><span class="hljs-params">(f *os.File, doc *Document)</span> <span class="hljs-title">error</span></span><br><br></code></pre></td></tr></table></figure>

<p>我可以指定这个函数 Save，它接受一个 *os.File 作为目标，用于写入 Document。但这有一些问题：</p>
<br>

<p>Save 的签名排除了将数据写入网络位置的选项。假设网络存储可能会在以后成为要求，该函数的签名将不得不更改，影响所有调用者。</p>
<br>

<p>Save 也不好测试，因为它直接与磁盘上的文件交互。因此，为了验证其操作，测试必须在写入后读取文件的内容。</p>
<br>

<p>我还必须确保 f 被写入到一个临时位置，并且始终在之后被移除。</p>
<br>

<p>*os.File 还定义了许多与 Save 无关的方法，如读取目录和检查路径是否为符号链接。如果 Save 函数的签名仅描述与其操作相关的 *os.File 部分，将会非常有用。</p>
<br>

<p>我们能做些什么呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Save writes the contents of doc to the supplied</span><br><span class="hljs-comment">// ReadWriterCloser.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Save</span><span class="hljs-params">(rwc io.ReadWriteCloser, doc *Document)</span> <span class="hljs-title">error</span></span><br></code></pre></td></tr></table></figure>

<p>使用 <code>io.ReadWriteCloser</code>，我们可以应用接口隔离原则，将 Save 重新定义为接受描述更一般的文件形状的接口。</p>
<br>

<p>通过这种改变，任何实现 <code>io.ReadWriteCloser</code> 接口的类型都可以替代以前的 *os.File。</p>
<br>

<p>这使得 <code>Save</code> 在应用范围上更广泛，并且使调用 <code>Save</code> 的用户更清楚地了解 <code>*os.File</code> 类型的哪些方法与其操作相关。</p>
<br>

<p>作为 <code>Save</code> 的作者，我也不再有在 <code>*os.File</code> 上调用那些不相关方法的选项，因为它已被隐藏在 <code>io.ReadWriteCloser</code> 接口后面。</p>
<br>

<p>但是我们可以进一步应用接口隔离原则。</p>
<br>

<p>首先，如果 <code>Save</code> 遵循单一职责原则，它不太可能读取刚刚写入的文件以验证其内容，这应该是另一段代码的责任。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Save writes the contents of doc to the supplied</span><br><span class="hljs-comment">// WriteCloser.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Save</span><span class="hljs-params">(wc io.WriteCloser, doc *Document)</span> <span class="hljs-title">error</span></span><br></code></pre></td></tr></table></figure>

<p>因此，我们可以将传递给 <code>Save</code> 的接口规范缩小为只写和关闭。</p>
<br>

<p>其次，通过为 <code>Save</code> 提供关闭其流的机制（我们在使其仍然看起来像一个文件的渴望中继承了这一点），这引发了在什么情况下 wc 将被关闭的问题。</p>
<br>

<p>可能 <code>Save</code> 会无条件地调用 <code>Close</code>，或者在成功的情况下调用 <code>Close</code>。</p>
<br>

<p>这对 <code>Save</code> 的调用者提出了一个问题，因为它可能希望在写入文档后向流中写入其他数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Save writes the contents of doc to the supplied</span><br><span class="hljs-comment">// Writer.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Save</span><span class="hljs-params">(w io.Writer, doc *Document)</span> <span class="hljs-title">error</span></span><br></code></pre></td></tr></table></figure>

<p>更好的解决方案是重新定义<code>Save</code>函数，仅接受一个<code>io.Writer</code>参数，完全摆脱除将数据写入流以外的任何责任。</p>
<br>

<p>通过将接口隔离原则应用于我们的<code>Save</code>函数，结果是一个具有最具体要求的函数——它只需要一个可写入的东西——以及最通用的函数，在函数中，我们现在可以使用<code>Save</code>将数据保存到任何实现了<code>io.Writer</code>接口的地方。</p>
<br>

<h2 id="7-错误处理"><a href="#7-错误处理" class="headerlink" title="7.错误处理"></a>7.错误处理</h2><br>

<p>我已经做了几次关于错误处理的演讲，并在我的博客上写了很多有关错误处理的文章。昨天的会议上，我也谈了很多关于错误处理的内容，因此我不会重复我所说的</p>
<ul>
<li>  <a target="_blank" rel="noopener" href="https://dave.cheney.net/2014/12/24/inspecting-errors" title="https://dave.cheney.net/2014/12/24/inspecting-errors">https://dave.cheney.net/2014/12/24/inspecting-errors</a></li>
<li>  <a target="_blank" rel="noopener" href="https://dave.cheney.net/2016/04/07/constant-errors" title="https://dave.cheney.net/2016/04/07/constant-errors">https://dave.cheney.net/2016/04/07/constant-errors</a></li>
</ul>
<p>相反，我想涵盖与错误处理相关的另外两个领域。</p>
<br>

<h3 id="7-1-通过消除错误来消除错误处理"><a href="#7-1-通过消除错误来消除错误处理" class="headerlink" title="7.1 通过消除错误来消除错误处理"></a>7.1 通过消除错误来消除错误处理</h3><br>

<p>如果你参加了我的演讲，我昨天谈到了改进错误处理的草案建议。但是，有什么比改进错误处理语法更好的呢？完全不需要处理错误。</p>
<br>

<blockquote>
<p><strong>TIP： 我并不是在说“移除你的错误处理”。我的建议是，改变你的代码，使得你没有需要处理的错误。 本节内容灵感来源于John Ousterhout最近出版的书《软件设计哲学》。该书的一个章节叫做“把错误定义消除掉”。我们将尝试将这个建议应用到Go语言中。</strong></p>
</blockquote>
<br>

<h4 id="7-1-1统计行数"><a href="#7-1-1统计行数" class="headerlink" title="7.1.1统计行数"></a>7.1.1统计行数</h4><br>

<p>让我们来写一个方法去统计一个文件的行数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CountLines</span><span class="hljs-params">(r io.Reader)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span> &#123;<br>  <span class="hljs-keyword">var</span> (<br>    br    = bufio.NewReader(r)<br>    lines <span class="hljs-keyword">int</span><br>    err   error<br>  )<br><br>  <span class="hljs-keyword">for</span> &#123;<br>    _, err = br.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>    lines++<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      <span class="hljs-keyword">break</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> err != io.EOF &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, err<br>  &#125;<br>  <span class="hljs-keyword">return</span> lines, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>因为我们遵循了前面章节的建议，CountLines 接受一个 io.Reader，而不是一个 *os.File；调用者提供我们要计算内容的 io.Reader。</p>
<br>

<p>我们构造一个 bufio.Reader，然后在一个循环中调用 ReadString 方法，逐行计数，直到文件结尾，然后返回读取的行数。</p>
<br>

<p>至少这是我们想要编写的代码，但是错误处理使得这个函数变得更加复杂。例如，有这个奇怪的结构，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">_, err = br.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>lines++<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>  <span class="hljs-keyword">break</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们在检查错误之前增加行数计数，这看起来很奇怪。</p>
<br>

<p>我们不得不这样写的原因是，如果 ReadString 在遇到换行符之前遇到文件结束，它会返回一个错误。如果文件中没有最后一个换行符，就会发生这种情况。</p>
<br>

<p>为了解决这个问题，我们重新安排逻辑，先增加行数计数，然后再检查是否需要退出循环。</p>
<br>

<blockquote>
<p><strong>NOTE：这个逻辑仍然不完美，你能找出错误吗？</strong></p>
</blockquote>
<br>

<p>但我们还没有完成检查错误的工作。当<code>ReadString</code>到达文件末尾时，它会返回<code>io.EOF</code>。这是预期的，<code>ReadString</code>需要一种停止读取的方法，表示没有更多内容可读。因此，在将错误返回给<code>CountLine</code>的调用者之前，我们需要检查错误是否不是<code>io.EOF</code>，在这种情况下将其向上传播，否则返回nil以表示一切正常。</p>
<br>

<p>我认为这是<strong>Russ Cox</strong>观察到的错误处理可能会掩盖函数操作的良好示例。让我们看一个改进版本。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CountLines</span><span class="hljs-params">(r io.Reader)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span> &#123;<br>  sc := bufio.NewScanner(r)<br>  lines := <span class="hljs-number">0</span><br><br>  <span class="hljs-keyword">for</span> sc.Scan() &#123;<br>    lines++<br>  &#125;<br>  <span class="hljs-keyword">return</span> lines, sc.Err()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个改进版本将使用<code>bufio.Scanner</code><strong>代替</strong><code>bufio.Reader</code>。</p>
<br>

<p>在幕后，<code>bufio.Scanner</code>使用<code>bufio.Reader</code>，但它添加了一个很好的抽象层，有助于消除遮盖<code>CountLines</code>操作的错误处理。</p>
<br>

<blockquote>
<p>NOTE： bufio.Scanner可以扫描任何模式，但默认情况下它会查找换行符。 </p>
</blockquote>
<br>

<p>方法<code>sc.Scan()</code><strong>返回</strong><code>true</code>，如果扫描器匹配了一行文本并且没有遇到错误。因此，我们的for循环体仅在扫描器缓冲区中有一行文本时调用。这意味着我们修订后的<code>CountLines</code>正确处理了没有尾随换行符的情况，也处理了文件为空的情况。</p>
<br>

<p>其次，由于<code>sc.Scan</code>遇到错误时会返回<code>false</code>，因此我们的for循环将在达到文件结尾或遇到错误时退出。<code>bufio.Scanner</code>类型记忆它遇到的第一个错误，我们可以使用<code>sc.Err()</code>方法在退出循环后恢复该错误。</p>
<br>

<p>最后，<code>sc.Err()</code>负责处理<code>io.EOF</code>，并将其转换为<code>nil</code>，如果在不遇到其他错误的情况下到达了文件结尾。</p>
<br>

<blockquote>
<p><strong>TIP：当你发现自己面对繁琐的错误处理时，尝试将一些操作提取到一个辅助类型中。</strong></p>
</blockquote>
<br>

<h4 id="7-1-2-WriteResponse"><a href="#7-1-2-WriteResponse" class="headerlink" title="7.1.2 WriteResponse"></a>7.1.2 WriteResponse</h4><br>

<p>我的第二个例子是受到《Errors are values》博客文章的启发。</p>
<br>

<p>在本次演示中，我们已经看到了处理打开、写入和关闭文件的示例。错误处理已经存在，但并不像操作可以封装在像 <strong><code>ioutil.ReadFile</code></strong> 和 <strong><code>ioutil.WriteFile</code></strong> 这样的辅助函数中那样压倒性。</p>
<br>

<p>然而，在处理低级网络协议时，需要直接使用I/O基元来构建响应，因此错误处理可能会变得重复。请考虑下面这个构建 HTTP 响应的片段，它是一个 HTTP 服务器的一部分。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Header <span class="hljs-keyword">struct</span> &#123;<br>  Key, Value <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Status <span class="hljs-keyword">struct</span> &#123;<br>  Code   <span class="hljs-keyword">int</span><br>  Reason <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WriteResponse</span><span class="hljs-params">(w io.Writer, st Status, headers []Header, body io.Reader)</span> <span class="hljs-title">error</span></span> &#123;<br>  _, err := fmt.Fprintf(w, <span class="hljs-string">&quot;HTTP/1.1 %d %s\r\n&quot;</span>, st.Code, st.Reason)<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> err<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> _, h := <span class="hljs-keyword">range</span> headers &#123;<br>    _, err := fmt.Fprintf(w, <span class="hljs-string">&quot;%s: %s\r\n&quot;</span>, h.Key, h.Value)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      <span class="hljs-keyword">return</span> err<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> _, err := fmt.Fprint(w, <span class="hljs-string">&quot;\r\n&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> err<br>  &#125;<br><br>  _, err = io.Copy(w, body)<br>  <span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先我们使用<code>fmt.Fprintf</code>构建状态行，并检查错误。然后对于每个标题，我们写入标题键和值，每次都检查错误。最后，我们使用额外的<code>\r\n</code>终止标题部分，检查错误，并将响应主体复制到客户端。最后，虽然我们不需要检查<code>io.Copy</code>的错误，但我们需要将其从<code>io.Copy</code><strong>返回的两个返回值形式翻译成</strong><code>WriteResponse</code>返回的单个返回值形式。</p>
<br>

<p>这是很多重复的工作。但我们可以通过引入一个小的包装类型<code>errWriter</code>来简化它。</p>
<br>

<p><code>errWriter</code>满足<code>io.Writer</code>契约，因此可以用来包装现有的<code>io.Writer</code>。<code>errWriter</code>将写入操作传递给其底层的写入器，直到检测到错误。从那时起，它会丢弃任何写入操作并返回先前的错误。</p>
<br>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> errWriter <span class="hljs-keyword">struct</span> &#123;<br>  io.Writer<br>  err error<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *errWriter)</span> <span class="hljs-title">Write</span><span class="hljs-params">(buf []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span> &#123;<br>  <span class="hljs-keyword">if</span> e.err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, e.err<br>  &#125;<br>  <span class="hljs-keyword">var</span> n <span class="hljs-keyword">int</span><br>  n, e.err = e.Writer.Write(buf)<br>  <span class="hljs-keyword">return</span> n, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WriteResponse</span><span class="hljs-params">(w io.Writer, st Status, headers []Header, body io.Reader)</span> <span class="hljs-title">error</span></span> &#123;<br>  ew := &amp;errWriter&#123;Writer: w&#125;<br>  fmt.Fprintf(ew, <span class="hljs-string">&quot;HTTP/1.1 %d %s\r\n&quot;</span>, st.Code, st.Reason)<br><br>  <span class="hljs-keyword">for</span> _, h := <span class="hljs-keyword">range</span> headers &#123;<br>    fmt.Fprintf(ew, <span class="hljs-string">&quot;%s: %s\r\n&quot;</span>, h.Key, h.Value)<br>  &#125;<br><br>  fmt.Fprint(ew, <span class="hljs-string">&quot;\r\n&quot;</span>)<br>  io.Copy(ew, body)<br>  <span class="hljs-keyword">return</span> ew.err<br>&#125;<br></code></pre></td></tr></table></figure>

<p>将<code>errWriter</code><strong>应用于</strong><code>WriteResponse</code><strong>显著提高了代码的清晰度。每个操作不再需要用错误检查括起来。通过检查</strong><code>ew.err</code><strong>字段，将报告错误移动到函数末尾，避免了从</strong><code>io.Copy</code>的返回值进行繁琐的转换。</p>
<br>

<h3 id="7-2-只处理错误一次"><a href="#7-2-只处理错误一次" class="headerlink" title="7.2 只处理错误一次"></a>7.2 只处理错误一次</h3><br>

<p>最后，我想提醒一下，您应该仅处理错误一次。处理错误意味着检查错误值并做出单一决策。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// WriteAll writes the contents of buf to the supplied writer.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WriteAll</span><span class="hljs-params">(w io.Writer, buf []<span class="hljs-keyword">byte</span>)</span></span> &#123;<br>        w.Write(buf)<br>&#125;<br><br></code></pre></td></tr></table></figure>



<p>如果您做出的决策少于一次，则忽略该错误。如我们在这里看到的，<code>w.WriteAll</code>的错误被丢弃了。</p>
<br>

<p>但是，对单个错误做出多个决策也是有问题的。以下是我经常遇到的代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WriteAll</span><span class="hljs-params">(w io.Writer, buf []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> &#123;<br>  _, err := w.Write(buf)<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Println(<span class="hljs-string">&quot;unable to write:&quot;</span>, err) <span class="hljs-comment">// annotated error goes to log file</span><br>    <span class="hljs-keyword">return</span> err                           <span class="hljs-comment">// unannotated error returned to caller</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，如果在<code>w.Write</code>过程中出现错误，将会写入一行日志文件，记录错误发生的文件和行数，并且错误也会被返回给调用者，调用者可能会记录它并将其返回，一直返回到程序的顶部。</p>
<br>

<p>调用者可能正在执行相同的操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WriteConfig</span><span class="hljs-params">(w io.Writer, conf *Config)</span> <span class="hljs-title">error</span></span> &#123;<br>  buf, err := json.Marshal(conf)<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Printf(<span class="hljs-string">&quot;could not marshal config: %v&quot;</span>, err)<br>    <span class="hljs-keyword">return</span> err<br>  &#125;<br>  <span class="hljs-keyword">if</span> err := WriteAll(w, buf); err != <span class="hljs-literal">nil</span> &#123;<br>    log.Println(<span class="hljs-string">&quot;could not write config: %v&quot;</span>, err)<br>    <span class="hljs-keyword">return</span> err<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>因此，你的日志文件中会有一堆重复的行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">unable to write: io.EOF<br>could not write config: io.EOF<br></code></pre></td></tr></table></figure>

<br>

<p>但是在程序的顶部，你会得到没有任何上下文的原始错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">err := WriteConfig(f, &amp;conf)<br>fmt.Println(err) <span class="hljs-comment">// io.EOF</span><br></code></pre></td></tr></table></figure>

<br>

<p>我想进一步探讨这个问题，因为我不认为记录和返回问题仅仅是个人喜好的问题。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WriteConfig</span><span class="hljs-params">(w io.Writer, conf *Config)</span> <span class="hljs-title">error</span></span> &#123;<br>  buf, err := json.Marshal(conf)<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Printf(<span class="hljs-string">&quot;could not marshal config: %v&quot;</span>, err)<br>    <span class="hljs-comment">// oops, forgot to return</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> err := WriteAll(w, buf); err != <span class="hljs-literal">nil</span> &#123;<br>    log.Println(<span class="hljs-string">&quot;could not write config: %v&quot;</span>, err)<br>    <span class="hljs-keyword">return</span> err<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>我经常看到的问题是程序员忘记从错误中返回。就像我们之前讨论的那样，Go的风格是使用<code>guard clauses</code>，随着函数的进行检查前置条件并早早地返回。</p>
<br>

<p>在这个例子中，作者检查了错误，记录了它，但是忘记了返回。这导致了一个微妙的错误。</p>
<br>

<p>Go中错误处理的约定是，在出现错误时不能对其他返回值的内容做出任何假设。由于<code>JSON marshalling</code>失败，buf的内容是未知的，它可能什么也没有，但更糟糕的是它可能包含一半写入的JSON片段。</p>
<br>

<p>由于程序员在检查和记录错误后忘记了返回，损坏的缓冲区将被传递给<code>WriteAll</code><strong>，它可能会成功，因此配置文件将被错误地写入。但是函数将正常返回，唯一表明出现问题的是一个关于</strong><code>marshalling JSON</code>的单个日志行，而不是写入配置的失败。</p>
<br>

<h4 id="7-2-1-给错误添加上下文"><a href="#7-2-1-给错误添加上下文" class="headerlink" title="7.2.1 给错误添加上下文"></a>7.2.1 给错误添加上下文</h4><br>

<p>这个错误的发生是因为作者试图给错误信息添加上下文。他们试图留下一个线索，指向错误来源。</p>
<br>

<p>让我们看看使用<code>fmt.Errorf</code>实现相同目的的另一种方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WriteConfig</span><span class="hljs-params">(w io.Writer, conf *Config)</span> <span class="hljs-title">error</span></span> &#123;<br>  buf, err := json.Marshal(conf)<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;could not marshal config: %v&quot;</span>, err)<br>  &#125;<br>  <span class="hljs-keyword">if</span> err := WriteAll(w, buf); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;could not write config: %v&quot;</span>, err)<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WriteAll</span><span class="hljs-params">(w io.Writer, buf []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">error</span></span> &#123;<br>  _, err := w.Write(buf)<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;write failed: %v&quot;</span>, err)<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过将错误注释与返回合并到一行中。</p>
<br>

<p>如果在写文件时发生I/O错误，则该错误的<code>Error()</code>方法将报告类似于以下内容的信息；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">could not write config: write failed: input/output error<br><br></code></pre></td></tr></table></figure>

<br>

<h4 id="7-2-2-使用github-com-pkg-errors去包装错误"><a href="#7-2-2-使用github-com-pkg-errors去包装错误" class="headerlink" title="7.2.2 使用github.com/pkg/errors去包装错误"></a>7.2.2 使用<a target="_blank" rel="noopener" href="http://github.com/pkg/errors" title="github.com/pkg/errors">github.com/pkg/errors</a>去包装错误</h4><br>

<p>fmt.Errorf模式适用于为错误消息添加注释，但是这样做会以掩盖原始错误类型为代价。我认为将错误视为不透明值对于生成松散耦合的软件非常重要，因此如果您对错误值所做的唯一操作是：</p>
<ul>
<li>  检查它不是nil。</li>
<li>  打印或记录它。</li>
</ul>
<br>

<p>那么原始错误的类型不应该有影响。</p>
<br>

<p>然而，我认为有一些情况（虽然很少见）需要恢复原始错误。在这种情况下，您可以使用类似我的错误包的东西来注释错误，如下所示。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReadFile</span><span class="hljs-params">(path <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> &#123;<br>  f, err := os.Open(path)<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.Wrap(err, <span class="hljs-string">&quot;open failed&quot;</span>)<br>  &#125;<br>  <span class="hljs-keyword">defer</span> f.Close()<br><br>  buf, err := ioutil.ReadAll(f)<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.Wrap(err, <span class="hljs-string">&quot;read failed&quot;</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> buf, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReadConfig</span><span class="hljs-params">()</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> &#123;<br>  home := os.Getenv(<span class="hljs-string">&quot;HOME&quot;</span>)<br>  config, err := ReadFile(filepath.Join(home, <span class="hljs-string">&quot;.settings.xml&quot;</span>))<br>  <span class="hljs-keyword">return</span> config, errors.WithMessage(err, <span class="hljs-string">&quot;could not read config&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  _, err := ReadConfig()<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    fmt.Println(err)<br>    os.Exit(<span class="hljs-number">1</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在错误就打印的很漂亮。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">could not read config: open failed: open /Users/dfc/.settings.xml: no such file or directory<br><br></code></pre></td></tr></table></figure>

<br>

<p>同时，错误也保留对原始原因的引用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  _, err := ReadConfig()<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;original error: %T %v\n&quot;</span>, errors.Cause(err), errors.Cause(err))<br>    fmt.Printf(<span class="hljs-string">&quot;stack trace:\n%+v\n&quot;</span>, err)<br>    os.Exit(<span class="hljs-number">1</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>您可以恢复原始错误并打印堆栈跟踪。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go">original error: *os.PathError open /Users/dfc/.settings.xml: no such file or directory<br>stack trace:<br>open /Users/dfc/.settings.xml: no such file or directory<br>open failed<br>main.ReadFile<br>        /Users/dfc/devel/practical-<span class="hljs-keyword">go</span>/src/errors/readfile2.<span class="hljs-keyword">go</span>:<span class="hljs-number">16</span><br>main.ReadConfig<br>        /Users/dfc/devel/practical-<span class="hljs-keyword">go</span>/src/errors/readfile2.<span class="hljs-keyword">go</span>:<span class="hljs-number">29</span><br>main.main<br>        /Users/dfc/devel/practical-<span class="hljs-keyword">go</span>/src/errors/readfile2.<span class="hljs-keyword">go</span>:<span class="hljs-number">35</span><br>runtime.main<br>        /Users/dfc/<span class="hljs-keyword">go</span>/src/runtime/proc.<span class="hljs-keyword">go</span>:<span class="hljs-number">201</span><br>runtime.goexit<br>        /Users/dfc/<span class="hljs-keyword">go</span>/src/runtime/asm_amd64.s:<span class="hljs-number">1333</span><br>could not read config<br></code></pre></td></tr></table></figure>

<p>使用errors包可以使您有能力向错误值添加上下文，这种方式可以由人和机器进行检查。</p>
<br>

<p>如果您昨天参加了我的演讲，您就会知道包装错误功能将在即将发布的Go版本中成为标准库的一部分。</p>
<br>

<h2 id="8-并发"><a href="#8-并发" class="headerlink" title="8.并发"></a>8.并发</h2><br>

<p>通常情况下，由于其并发特性，人们会选择使用Go语言来开发项目。Go团队花费了很大的力气来使Go语言中的并发操作廉价（指硬件资源）和高效，然而使用Go的并发特性编写既不高效也不可靠的代码也是有可能的。在我还剩下的时间里，我想给大家一些建议，以避免Go并发特性带来的一些陷阱。</p>
<br>

<p>Go语言具有通道（**<code>channels</code><strong>）、选择语句（</strong><code>select statement</code><strong>）和go语句（</strong><code>go statement</code>**）等优秀的并发支持。如果你从书本或培训课程中正式学习Go语言，你可能会注意到并发部分总是最后一个学习的章节。</p>
<br>

<p>这里存在一种二元对立；Go语言的标志性特征就是我们简单、轻量级的并发模型。作为产品，我们的语言几乎凭借这个特性就能自行销售。另一方面，有一种说法认为，并发实际上并不容易使用，否则，作者们不会把它放在书本的最后一章，我们也不会对我们的基础工作感到后悔。</p>
<br>

<p>本节讨论使用Go并发特性时的一些陷阱。</p>
<br>

<h3 id="8-1-让自己保持忙碌，或者自己动手完成工作"><a href="#8-1-让自己保持忙碌，或者自己动手完成工作" class="headerlink" title="8.1 让自己保持忙碌，或者自己动手完成工作"></a>8.1 让自己保持忙碌，或者自己动手完成工作</h3><br>

<p>下面这段程序有什么问题？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">&quot;fmt&quot;</span><br>  <span class="hljs-string">&quot;log&quot;</span><br>  <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    fmt.Fprintln(w, <span class="hljs-string">&quot;Hello, GopherCon SG&quot;</span>)<br>  &#125;)<br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br>      log.Fatal(err)<br>    &#125;<br>  &#125;()<br><br>  <span class="hljs-keyword">for</span> &#123;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>该程序实现了我们的意图，它作为一个简单的 Web 服务器提供服务。然而，它同时也在做另一件事情，它在一个无限循环中浪费 CPU。这是因为 main 函数的最后一行中的 <code>for&#123;&#125;</code>会阻塞主 <code>goroutine</code>，因为它不进行任何 <code>IO</code> 操作，不等待锁、不发送或接收通道消息，或以其他方式与调度程序进行通信。</p>
<br>

<p>由于 Go 运行时大多是协作调度的，这个程序会在一个单独的 CPU 上毫无意义地旋转，最终可能会陷入活锁状态。</p>
<br>

<p>我们该如何修复这个问题？以下是一个建议。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">&quot;fmt&quot;</span><br>  <span class="hljs-string">&quot;log&quot;</span><br>  <span class="hljs-string">&quot;net/http&quot;</span><br>  <span class="hljs-string">&quot;runtime&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    fmt.Fprintln(w, <span class="hljs-string">&quot;Hello, GopherCon SG&quot;</span>)<br>  &#125;)<br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br>      log.Fatal(err)<br>    &#125;<br>  &#125;()<br><br>  <span class="hljs-keyword">for</span> &#123;<br>    runtime.Gosched()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这可能看起来很傻，但我在实践中看到过这种常见的解决方案。这表明没理解潜在问题的症状。</p>
<br>

<p>现在，如果你对 Go 有更多的经验，你可能会编写类似于以下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">&quot;fmt&quot;</span><br>  <span class="hljs-string">&quot;log&quot;</span><br>  <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    fmt.Fprintln(w, <span class="hljs-string">&quot;Hello, GopherCon SG&quot;</span>)<br>  &#125;)<br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br>      log.Fatal(err)<br>    &#125;<br>  &#125;()<br><br>  <span class="hljs-keyword">select</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>一个空的 select 语句将永远阻塞。这是一个有用的特性，因为现在我们不再通过调用 <code>runtime.GoSched()</code> 来旋转整个 CPU。然而，我们只是在处理症状，而不是病因。</p>
<br>

<p>我想给你提供另一种解决方案，希望你已经想到了。不要在一个 <code>goroutine</code> 中运行 <code>http.ListenAndServe</code>，从而避免了如何处理主 <code>goroutine</code> 的问题，而是直接在主 <code>goroutine</code> 上运行 <code>http.ListenAndServe</code>。</p>
<br>

<blockquote>
<p><strong>TIP：如果 Go 程序的 main.main 函数返回，则不论程序随时间启动了多少其他 goroutine，程序都会无条件退出。</strong></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">&quot;fmt&quot;</span><br>  <span class="hljs-string">&quot;log&quot;</span><br>  <span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>    fmt.Fprintln(w, <span class="hljs-string">&quot;Hello, GopherCon SG&quot;</span>)<br>  &#125;)<br>  <span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">&quot;:8080&quot;</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(err)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<br>

<p>因此，这是我给出的第一个建议：如果你的 <code>goroutine</code> 无法取得进展，直到它从另一个 <code>goroutine</code> 获取结果，那么通常更简单的方法是自己完成工作，而不是委托给其他 <code>goroutine</code>。</p>
<br>

<p>这通常可以消除许多状态跟踪和通道操作，这些操作需要将结果从一个 <code>goroutine</code> 汇集到其启动者那里。</p>
<br>

<blockquote>
<p><strong>TIP：许多 Go 程序员在刚开始时过度使用 goroutine。像生活中的所有事情一样，适度是成功的关键。</strong></p>
</blockquote>
<br>

<h3 id="8-2将并发留给调用者"><a href="#8-2将并发留给调用者" class="headerlink" title="8.2将并发留给调用者"></a>8.2将并发留给调用者</h3><br>

<p>这两个API有什么区别？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// ListDirectory returns the contents of dir.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ListDirectory</span><span class="hljs-params">(dir <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">([]<span class="hljs-keyword">string</span>, error)</span></span><br><span class="hljs-comment">// ListDirectory returns a channel over which</span><br><span class="hljs-comment">// directory entries will be published. When the list</span><br><span class="hljs-comment">// of entries is exhausted, the channel will be closed.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ListDirectory</span><span class="hljs-params">(dir <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">chan</span> <span class="hljs-title">string</span></span><br></code></pre></td></tr></table></figure>

<p>首先，显而易见的区别是，第一个例子将一个目录读入一个切片中，然后返回整个切片，如果出现错误则返回一个错误。这是同步发生的，<code>ListDirectory</code>的调用者会阻塞，直到所有目录条目都被读取。根据目录的大小，这可能需要很长时间，并且可能会分配大量内存来构建目录条目名称的切片。</p>
<br>

<p>现在看看第二个例子。这更像Go，<code>ListDirectory</code>返回一个通道，通过该通道传递目录条目。当通道关闭时，表示没有更多目录条目了。由于通道的填充发生在<code>ListDirectory</code>返回之后，<code>ListDirectory</code>可能会启动一个<code>goroutine</code>来填充通道。</p>
<br>

<blockquote>
<p><strong>NOTE：第二个版本并不一定需要实际使用Go程；它可以分配足够的通道以容纳所有目录条目而不阻塞，填充通道，关闭通道，然后将通道返回给调用者。但这不太可能发生，因为这样做会在使用通道缓冲所有结果时出现相同的内存消耗问题</strong>。</p>
</blockquote>
<br>

<p><code>ListDirectory</code>的通道版本存在两个进一步的问题：</p>
<br>

<p>使用关闭的通道作为信号表明没有更多的项目需要处理，这种方式无法让<code>ListDirectory</code>告诉调用者返回的项目集合是不完整的，因为在处理过程中遇到了错误。调用者无法区分空目录和完全读取目录时的错误。两者都会导致从<code>ListDirectory</code>返回的通道立即关闭。</p>
<br>

<p>调用者必须继续从通道中读取数据，直到通道关闭，因为这是调用者唯一能知道用于填充通道的<code>goroutine</code>已经停止的方法。这对于使用<code>ListDirectory</code>是一个严重的限制，即使调用者可能已经得到了想要的答案，也必须花费时间从通道中读取数据。在中到大型目录的内存使用方面可能更有效率，但是这种方法并不比原始的基于切片的方法更快。</p>
<br>

<p>解决两种实现问题的方法是使用回调，即在执行每个目录条目的上下文中调用的函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ListDirectory</span><span class="hljs-params">(dir <span class="hljs-keyword">string</span>, fn <span class="hljs-keyword">func</span>(<span class="hljs-keyword">string</span>)</span>)</span><br><br></code></pre></td></tr></table></figure>

<p>毫不奇怪，这就是<code>filepath.WalkDir</code>函数的工作方式。</p>
<br>

<blockquote>
<p><strong>TIP：如果您的函数启动了一个goroutine，您必须为调用者提供一种明确停止该goroutine的方式。通常，将异步执行函数的决定留给该函数的调用者更容易实现。</strong></p>
</blockquote>
<br>

<h3 id="8-3-在不知道-goroutine-何时停止的情况下，永远不要启动它"><a href="#8-3-在不知道-goroutine-何时停止的情况下，永远不要启动它" class="headerlink" title="8.3 在不知道 goroutine 何时停止的情况下，永远不要启动它"></a>8.3 在不知道 goroutine 何时停止的情况下，永远不要启动它</h3><br>

<p>之前的例子展示了在不必要使用 <code>goroutine</code> 的情况下使用它的方法。但使用 Go 的一个主要原因是该语言提供了一流的并发特性。确实，有很多情况下你想要利用硬件可用的并行性。为了这样做，你必须使用 <code>goroutines</code>。</p>
<br>

<p>这个简单的应用程序在两个不同的端口上提供 http 流量，8080 端口用于应用程序流量，8001 端口用于访问 <code>/debug/pprof</code>终端点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>  <span class="hljs-string">&quot;fmt&quot;</span><br>  <span class="hljs-string">&quot;net/http&quot;</span><br>  _ <span class="hljs-string">&quot;net/http/pprof&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  mux := http.NewServeMux()<br>  mux.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;<br>    fmt.Fprintln(resp, <span class="hljs-string">&quot;Hello, QCon!&quot;</span>)<br>  &#125;)<br>  <span class="hljs-keyword">go</span> http.ListenAndServe(<span class="hljs-string">&quot;127.0.0.1:8001&quot;</span>, http.DefaultServeMux) <span class="hljs-comment">// debug</span><br>  http.ListenAndServe(<span class="hljs-string">&quot;0.0.0.0:8080&quot;</span>, mux)                       <span class="hljs-comment">// app traffic</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>虽然这个程序并不是非常复杂，但它代表了一个真实应用程序的基础。</p>
<br>

<p>随着应用程序的发展，它目前存在一些问题，因此现在让我们解决其中一些问题。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">serveApp</span><span class="hljs-params">()</span></span> &#123;<br>  mux := http.NewServeMux()<br>  mux.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;<br>    fmt.Fprintln(resp, <span class="hljs-string">&quot;Hello, QCon!&quot;</span>)<br>  &#125;)<br>  http.ListenAndServe(<span class="hljs-string">&quot;0.0.0.0:8080&quot;</span>, mux)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">serveDebug</span><span class="hljs-params">()</span></span> &#123;<br>  http.ListenAndServe(<span class="hljs-string">&quot;127.0.0.1:8001&quot;</span>, http.DefaultServeMux)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">go</span> serveDebug()<br>  serveApp()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过将 <code>serveApp</code> 和 <code>serveDebug</code> 处理程序拆分成它们自己的函数，我们将它们与 <code>main.main</code> 分离开来。我们也遵循了上面的建议，确保 <code>serveApp</code> 和 <code>serveDebug</code> 将并发留给调用者。</p>
<br>

<p>但是，这个程序存在一些可操作性问题。如果 <code>serveApp</code> 返回，那么 <code>main.main</code> 将返回，导致程序关闭并被您使用的任何进程管理器重新启动。</p>
<br>

<p>提示：就像在 Go 中的函数将并发留给调用者一样，应用程序也应该将监视它们的状态和在它们失败时重新启动它们的工作留给调用它们的程序。不要让您的应用程序负责自我重启，这是最好从应用程序外部处理的程序。</p>
<br>

<p>但是，<code>serveDebug</code> 在一个单独的 <code>goroutine</code> 中运行，如果它返回，那么只有该 <code>goroutine</code> 会退出，而程序的其余部分会继续运行。当运维人员想要获取您的应用程序的统计信息时，他们可能会发现无法获得 /debug 处理程序的工作状态，因为它很久以前就停止工作了。</p>
<br>

<p>我们要确保的是，如果负责服务这个应用程序的任何 <code>goroutine</code> 停止了，我们将关闭该应用程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">serveApp</span><span class="hljs-params">()</span></span> &#123;<br>  mux := http.NewServeMux()<br>  mux.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;<br>    fmt.Fprintln(resp, <span class="hljs-string">&quot;Hello, QCon!&quot;</span>)<br>  &#125;)<br>  <span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">&quot;0.0.0.0:8080&quot;</span>, mux); err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(err)<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">serveDebug</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">if</span> err := http.ListenAndServe(<span class="hljs-string">&quot;127.0.0.1:8001&quot;</span>, http.DefaultServeMux); err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(err)<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">go</span> serveDebug()<br>  <span class="hljs-keyword">go</span> serveApp()<br>  <span class="hljs-keyword">select</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在，<code>serverApp</code> 和 <code>serveDebug</code> 检查 <code>ListenAndServe</code> 返回的错误，必要时调用 <code>log.Fatal</code>。因为这两个处理程序都在 <code>goroutine</code> 中运行，我们将主 <code>goroutine</code> 放置在 <code>select&#123;&#125;</code> 中。</p>
<br>

<p>这种方法存在一些问题：如果 <code>ListenAndServe</code> 返回一个 nil 错误，<code>log.Fatal</code> 将不会被调用，该端口上的 HTTP 服务将关闭而不会停止应用程序。</p>
<br>

<p><code>log.Fatal</code> 调用 <code>os.Exit</code>，这将无条件退出程序；延迟调用将不会被执行，其他 <code>goroutine</code> 将不会被通知关闭，程序将会立即停止。这使得很难为这些函数编写测试。</p>
<br>

<blockquote>
<p><strong>TIP：只在 main.main 或 init 函数中使用 log.Fatal</strong></p>
</blockquote>
<br>

<p>我们真正想要的是将发生的任何错误传递回 <code>goroutine</code> 的原始调用者，以便它可以知道为什么该 <code>goroutine</code> 停止，并可以干净地关闭进程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">serveApp</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br>  mux := http.NewServeMux()<br>  mux.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;<br>    fmt.Fprintln(resp, <span class="hljs-string">&quot;Hello, QCon!&quot;</span>)<br>  &#125;)<br>  <span class="hljs-keyword">return</span> http.ListenAndServe(<span class="hljs-string">&quot;0.0.0.0:8080&quot;</span>, mux)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">serveDebug</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br>  <span class="hljs-keyword">return</span> http.ListenAndServe(<span class="hljs-string">&quot;127.0.0.1:8001&quot;</span>, http.DefaultServeMux)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> error, <span class="hljs-number">2</span>)<br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    done &lt;- serveDebug()<br>  &#125;()<br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    done &lt;- serveApp()<br>  &#125;()<br><br>  <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">cap</span>(done); i++ &#123;<br>    <span class="hljs-keyword">if</span> err := &lt;-done; err != <span class="hljs-literal">nil</span> &#123;<br>      fmt.Println(<span class="hljs-string">&quot;error: %v&quot;</span>, err)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们可以使用一个通道来收集 <code>goroutine</code> 的返回状态。通道的大小等于我们要管理的 <code>goroutine</code> 数量，这样发送到 done 通道将不会阻塞，因为这将阻塞 <code>goroutine</code> 的关闭，导致其泄漏。</p>
<br>

<p>由于没有安全地关闭 <code>done</code> 通道的方法，我们无法使用 <code>for range</code> 习惯用法循环遍历通道，直到所有 <code>goroutine</code> 都报告完成，而是循环处理我们启动的 <code>goroutine</code> 数量，这等于通道的容量。</p>
<br>

<p>现在我们有了一种等待每个 <code>goroutine</code> 干净退出并记录它们遇到的任何错误的方法。我们需要的是一种方法将关闭信号从第一个退出的 <code>goroutine</code> 转发到其他 <code>goroutine</code>。</p>
<br>

<p>事实证明，要求 <code>http.Server</code> 关闭有点复杂，因此我已将该逻辑分解为辅助函数。<code>serve</code> 辅助函数接受一个地址和 <code>http.Handler</code>，类似于 <code>http.ListenAndServe</code>，还有一个停止通道，我们使用该通道触发 <code>Shutdown</code> 方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">serve</span><span class="hljs-params">(addr <span class="hljs-keyword">string</span>, handler http.Handler, stop &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;<br>  s := http.Server&#123;<br>    Addr:    addr,<br>    Handler: handler,<br>  &#125;<br><br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    &lt;-stop <span class="hljs-comment">// wait for stop signal</span><br>    s.Shutdown(context.Background())<br>  &#125;()<br><br>  <span class="hljs-keyword">return</span> s.ListenAndServe()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">serveApp</span><span class="hljs-params">(stop &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;<br>  mux := http.NewServeMux()<br>  mux.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;<br>    fmt.Fprintln(resp, <span class="hljs-string">&quot;Hello, QCon!&quot;</span>)<br>  &#125;)<br>  <span class="hljs-keyword">return</span> serve(<span class="hljs-string">&quot;0.0.0.0:8080&quot;</span>, mux, stop)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">serveDebug</span><span class="hljs-params">(stop &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;<br>  <span class="hljs-keyword">return</span> serve(<span class="hljs-string">&quot;127.0.0.1:8001&quot;</span>, http.DefaultServeMux, stop)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> error, <span class="hljs-number">2</span>)<br>  stop := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    done &lt;- serveDebug(stop)<br>  &#125;()<br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    done &lt;- serveApp(stop)<br>  &#125;()<br><br>  <span class="hljs-keyword">var</span> stopped <span class="hljs-keyword">bool</span><br>  <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">cap</span>(done); i++ &#123;<br>    <span class="hljs-keyword">if</span> err := &lt;-done; err != <span class="hljs-literal">nil</span> &#123;<br>      fmt.Println(<span class="hljs-string">&quot;error: %v&quot;</span>, err)<br>    &#125;<br>    <span class="hljs-keyword">if</span> !stopped &#123;<br>      stopped = <span class="hljs-literal">true</span><br>      <span class="hljs-built_in">close</span>(stop)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在，每当我们从<code>done</code>通道中收到一个值，我们就关闭<code>stop</code>通道，这将导致等待该通道的所有goroutine关闭它们的<code>http.Server</code>。这反过来又会导致所有剩余的<code>ListenAndServe</code> goroutine 返回。一旦我们启动的所有goroutine都停止了，<code>main.main</code>就会返回，进程会干净地停止。</p>
<br>

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_1" title="1">1</a>. <a target="_blank" rel="noopener" href="https://gaston.life/books/effective-programming/" title="https://gaston.life/books/effective-programming/">https://gaston.life/books/effective-programming/</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_2" title="2">2</a>. <a target="_blank" rel="noopener" href="https://talks.golang.org/2014/names.slide#4" title="https://talks.golang.org/2014/names.slide#4">https://talks.golang.org/2014/names.slide#4</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_3" title="3">3</a>. <a target="_blank" rel="noopener" href="https://www.infoq.com/articles/API-Design-Joshua-Bloch" title="https://www.infoq.com/articles/API-Design-Joshua-Bloch">https://www.infoq.com/articles/API-Design-Joshua-Bloch</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_1" title="1">1</a>. <a target="_blank" rel="noopener" href="https://www.lysator.liu.se/c/pikestyle.html" title="https://www.lysator.liu.se/c/pikestyle.html">https://www.lysator.liu.se/c/pikestyle.html</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_2" title="2">2</a>. <a target="_blank" rel="noopener" href="https://speakerdeck.com/campoy/understanding-nil" title="https://speakerdeck.com/campoy/understanding-nil">https://speakerdeck.com/campoy/understanding-nil</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_3" title="3">3</a>. <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=Ic2y6w8lMPA" title="https://www.youtube.com/watch?v=Ic2y6w8lMPA">https://www.youtube.com/watch?v=Ic2y6w8lMPA</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_4" title="4">4</a>. <a target="_blank" rel="noopener" href="https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88" title="https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88">https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_5" title="5">5</a>. <a target="_blank" rel="noopener" href="https://golang.org/doc/go1.4#internalpackages" title="https://golang.org/doc/go1.4#internalpackages">https://golang.org/doc/go1.4#internalpackages</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_6" title="6">6</a>. <a target="_blank" rel="noopener" href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis" title="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis">https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_7" title="7">7</a>. <a target="_blank" rel="noopener" href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html" title="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html">https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_8" title="8">8</a>. <a target="_blank" rel="noopener" href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully" title="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_9" title="9">9</a>. <a target="_blank" rel="noopener" href="https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201" title="https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201">https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_10" title="10">10</a>. <a target="_blank" rel="noopener" href="https://blog.golang.org/errors-are-values" title="https://blog.golang.org/errors-are-values">https://blog.golang.org/errors-are-values</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_11" title="11">11</a>. <a target="_blank" rel="noopener" href="http://www.gopl.io/" title="http://www.gopl.io/">http://www.gopl.io/</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/golang/">golang</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/11/24/%E8%B0%88%E8%B0%88%E5%AF%B9%E9%95%BF%E8%BF%9E%E6%8E%A5%E7%BD%91%E5%85%B3%E6%9E%B6%E6%9E%84%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89/">
                        <span class="hidden-mobile">谈谈对长连接网关架构的设计（二）</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
